<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARL KMCThinFilm: Illustrating the usage of the ARL KMCThinFilm library by example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ARL KMCThinFilm<span id="projectnumber">&#160;0.2.7</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('illustrating_use_by_example.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Illustrating the usage of the ARL KMCThinFilm library by example</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Perhaps the best way to showcase the functionality of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library is to provide examples of its use, so several examples will be shown here. The first example is a very basic solid-on-solid model and only requires a two-dimensional lattice. It is intended to give an overall sense of how the library is meant to be used. The second example shows what is needed to implement a parallel kinetic Monte Carlo simulation with this library. The third example is slightly less simple in that it shows how to implement a three-dimensional simulation, and it shows a few other features of the library. The fourth example involves a model of a patterned substrate that encourages two-dimensional island formation at regular places along a grid. It is meant to show how the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library can be used to speed the implementation of models with features that could require custom code to implement, and again shows some new features of the library not mentioned in previous examples. It is expected that these examples be read <em>in order</em>, since matters discussed in detail in a previous example may be reviewed only briefly, if at all, in later examples. It is also recommended to read all of the examples, in order to get a better overview of the library's features.</p>
<h1><a class="anchor" id="example_fractal"></a>
Example: Implementation of a &ldquo;fractal&rdquo; solid-on-solid model</h1>
<p>This example implements a &ldquo;fractal&rdquo; kinetic Monte Carlo model (similar to that described in the work that developed the approximate semirigorous parallel kMC <a class="el" href="citelist.html#CITEREF_shim05">[10]</a>). In this simple model, the lattice is simple cubic. The fractal model has two kinds of possible events: deposition and diffusion. The deposition flux, i.e. propensity per unit area, is <em>F</em> monolayers per unit time. Here, diffusion is a hop of a particle from one lattice site to a nearest neighboring site. Furthermore, in this model, a particle can only diffuse if it has no lateral nearest or next-nearest neighbors. This causes the particles to form a surface somewhat reminiscent of snowflakes. If a diffusion event can occur, it occurs with propensity <em>D</em>.</p>
<p>Since this is a solid-on-solid model, if a diffusing particle moves to a site that is not just above another particle, then the diffusing particle will fall until it lands on top of another particle. This guarantees no vacancies, and it also means that the three-dimensional <em>true</em> lattice, where each cell is either occupied or unoccupied, does not have to be explicitly modeled. Instead, a <em>computational</em> lattice is used that has the same lateral dimensions as the cubic true lattice but always contains only a single lattice plane, and the height of the column of particles at cell \((i,j,0)\) of the true lattice is recorded at cell \((i,j,0)\) of the lattice used for computation.</p>
<p>There will actually be <em>two</em> implementations shown in this example: one using auto-tracking to determine the cells affected by an event, and one using semi-manual tracking.</p>
<h2><a class="anchor" id="ex_fractal_auto_tracking"></a>
Using auto-tracking</h2>
<p>The code for this example is in the directory <code>doc/example-code/testFractal</code> of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> installation. We will begin by viewing what is effectively the driver file for the simulation code, <code>testFractal.cpp</code>, which will show the general outline of the simulation, but leave in a few &ldquo;blanks&rdquo; to be filled in, so to speak. To fill in these blanks, we will then turn to the files <code>EventsAndActions.hpp</code> and <code>EventsAndActions.cpp</code>, where the implementation code lies.</p>
<h3><a class="anchor" id="ex_fractal_driver"></a>
Examining the driver code</h3>
<p>The header files needed by <code>testFractal.cpp</code> are as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;KMCThinFilm/Simulation.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;KMCThinFilm/RandNumGenMT19937.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;EventsAndActions.hpp&quot;</span></div>
</div><!-- fragment --><p>The last of these headers, <code>EventsAndActions.hpp</code>, was mentioned above and will be discussed in more detail later. The remaining headers include the definitions for the <a class="el" href="classKMCThinFilm_1_1Simulation.html">KMCThinFilm::Simulation</a> class and a wrapper class for a Mersenne Twister random number generator. Here, any available concrete implementation of the <a class="el" href="classKMCThinFilm_1_1RandNumGen.html">KMCThinFilm::RandNumGen</a> class could have been used in place of <a class="el" href="classKMCThinFilm_1_1RandNumGenMT19937.html">KMCThinFilm::RandNumGenMT19937</a>. In order to avoid having to type the prefix &ldquo;<code><a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a>::</code>&rdquo; repeatedly, the next line is</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceKMCThinFilm.html">KMCThinFilm</a>;</div>
</div><!-- fragment --><p>At the beginning of the <code>main()</code> function in <code>testFractal.cpp</code>, we have the following hard-coded parameters:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> F = 1, DoverF = 1e5, maxCoverage = 4;</div>
<div class="line">  <span class="keywordtype">int</span> domainSize = 256;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> seed = 42;</div>
<div class="line">  <a class="code hl_enumeration" href="namespaceKMCThinFilm_1_1SolverId.html#a43b0b7ee9ab985e86a13450beb2c7523">SolverId::Type</a> sId = <a class="code hl_enumvalue" href="namespaceKMCThinFilm_1_1SolverId.html#a43b0b7ee9ab985e86a13450beb2c7523a66b6c59bbaeb00525c6dd96af1b33563">SolverId::DYNAMIC_SCHULZE</a>;</div>
</div><!-- fragment --><p>The first several parameters pertain to the fractal model itself. Parameter <code>F</code> is the aforementioned deposition flux <em>F</em>, while <code>DoverF</code> is <em>D</em>/<em>F</em>. The parameter <code>maxCoverage</code> indicates how many monolayers to deposit, and <code>domainSize</code> will be used to set the size of the lattice.</p>
<p>The last two parameters relate more to the computation of the kinetic Monte Carlo simulation. The parameter <code>seed</code> is the seed for the random number generator. Parameter <code>sId</code> indicates which solver will be used to randomly choose an event at a time step in the simulation.</p>
<dl class="section note"><dt>Note</dt><dd>The parameters are only hard-coded in order to simplify the example. In a more realistic simulation code, one could use, for example, the Program Options library of Boost &lt;<a href="http://www.boost.org">http://www.boost.org</a>&gt; to input the parameters, especially since Boost is already a dependency of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library.</dd></dl>
<p>To determine the simulation time needed to deposit the desired number of monolayers, <code>maxCoverage</code> is divided by the flux <code>F</code>, so the next line of <code>testFractal.cpp</code> reads</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> approxDepTime = maxCoverage/F;</div>
</div><!-- fragment --><p>At this point, the simulation itself is initialized. To do this, the parameters needed to initialize the lattice used in the simulation are passed to the constructor of a <a class="el" href="classKMCThinFilm_1_1Simulation.html">KMCThinFilm::Simulation</a> object:</p>
<div class="fragment"><div class="line">  <a class="code hl_struct" href="structKMCThinFilm_1_1LatticeParams.html">LatticeParams</a> latParams;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a7a9d46d27758a276fd20d9c18156371a">numIntsPerCell</a> = FIntVal::SIZE;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3a3cc62a6fb5fdda00ed2c63e1ff1020">globalPlanarDims</a>[0] = latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3a3cc62a6fb5fdda00ed2c63e1ff1020">globalPlanarDims</a>[1] = domainSize;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1Simulation.html">Simulation</a> sim(latParams);</div>
</div><!-- fragment --><p>Here, the size of the array of integers in each lattice cell is set to <code>FIntVal::SIZE</code>, which will turn out to be an enumeration constant defined in <code>EventsAndActions.hpp</code>. It was mentioned before that <code>domainSize</code> will be used to set the size of the lattice. Now here, the lateral size of the lattice has been set to <code>domainSize</code> &times; <code>domainSize</code>.</p>
<p>The choice of solver and random number generator for the simulation are now set:</p>
<div class="fragment"><div class="line">  sim.setSolver(sId);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">RandNumGenSharedPtr</a> rng(<span class="keyword">new</span> <a class="code hl_class" href="classKMCThinFilm_1_1RandNumGenMT19937.html">RandNumGenMT19937</a>(seed));</div>
<div class="line"> </div>
<div class="line">  sim.setRNG(rng);</div>
</div><!-- fragment --><p>The order of the above statements matters, since <a class="el" href="classKMCThinFilm_1_1Simulation.html#aab6ce6b8f7013c7ce3bcedb8fc3cc469">KMCThinFilm::Simulation::setRNG()</a> must be called <em>after</em> <a class="el" href="classKMCThinFilm_1_1Simulation.html#adf613f2cf2520695a0fb2ddbbdfd2328">KMCThinFilm::Simulation::setSolver()</a>. Here, a &ldquo;smart&rdquo; pointer to an instance of a <a class="el" href="classKMCThinFilm_1_1RandNumGen.html">KMCThinFilm::RandNumGen</a> class is passed to our <a class="el" href="classKMCThinFilm_1_1Simulation.html">KMCThinFilm::Simulation</a> object, <code>sim</code>. Since this is a shared pointer, <code>sim</code> does not exclusively own this pointer. Instead, this pointer deletes itself when there are no more references to it. (Also, if need be, other objects besides <code>sim</code> are allowed to make use of this pointer to generate random numbers of their own, but that will not be an issue in this simple example.)</p>
<p>At this point, <em>possible events</em> and <em>periodic actions</em> may be added to the simulation. We begin by adding a possible deposition event:</p>
<div class="fragment"><div class="line">  sim.reserveOverLatticeEvents(FOverLatticeEvents::SIZE);</div>
<div class="line">  sim.addOverLatticeEvent(FOverLatticeEvents::DEPOSITION,</div>
<div class="line">                          F, DepositionExecute);</div>
</div><!-- fragment --><p>This code adds possible so-called <em>over-lattice</em> events, which are events that may originate from some randomly picked site at the top of the lattice, as discussed in the section entitled &ldquo;<a class="el" href="concepts_and_algorithms.html#kMC_sim_overview">Basics of kinetic Monte Carlo simulation as implemented in the ARL KMCThinFilm library</a>.&rdquo; For example, deposition of a particle can be modeled as an event where a particle appears randomly at the top of the lattice and falls until it lands atop an occupied lattice site.</p>
<p>The member function <a class="el" href="classKMCThinFilm_1_1Simulation.html#a21587717d5f10a6ae3b8c3606752db13">KMCThinFilm::Simulation::reserveOverLatticeEvents()</a> sets the number of possible over-lattice events that will be added to the simulation and reserves memory for them. Here, the number of such events is <code>FOverLatticeEvents::SIZE</code>, another enumeration constant defined in <code>EventsAndActions.hpp</code>. The member function <a class="el" href="classKMCThinFilm_1_1Simulation.html#affa3dff53afd248546457944b98376d9">KMCThinFilm::Simulation::addOverLatticeEvent()</a> actually adds the event to the simulation. The three arguments that it takes are an integer label identifying the event, which here is another enumeration constant <code>FOverLatticeEvents::DEPOSITION</code>; a propensity per unit of in-plane area, that is, the flux <em>F</em>; and a function or function object responsible for actually executing the event, which here is <code>DepositionExecute</code>. (The actual propensity of the event is the propensity per area scaled by the size of a monolayer of lattice cells, i.e., <code>latParams.globalPlanarDims[0]</code> &times; <code>latParams.globalPlanarDims[1]</code>.)</p>
<p>We now begin to add <em>cell-centered</em> events to the simulation. Again, as discussed in the section entitled &ldquo;<a class="el" href="concepts_and_algorithms.html#kMC_sim_overview">Basics of kinetic Monte Carlo simulation as implemented in the ARL KMCThinFilm library</a>,&rdquo; these events are called such because such events originate in the neighborhood of some lattice cell, and their propensities&mdash;unlike those of over-lattice events&mdash;<em>are</em> affected by the states of cells in that neighborhood. This neighborhood is defined via one or more <em>offsets</em> from a central cell, as follows:</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellNeighOffsets.html">CellNeighOffsets</a> hopCNO(HopOffset::SIZE);</div>
<div class="line"> </div>
<div class="line">  hopCNO.addOffset(HopOffset::UP,    <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(0,+1,0));</div>
<div class="line">  hopCNO.addOffset(HopOffset::DOWN,  <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(0,-1,0));</div>
<div class="line">  hopCNO.addOffset(HopOffset::LEFT,  <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(-1,0,0));</div>
<div class="line">  hopCNO.addOffset(HopOffset::RIGHT, <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(+1,0,0));</div>
<div class="line"> </div>
<div class="line">  hopCNO.addOffset(HopOffset::RIGHT_UP,   <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(+1,+1,0));</div>
<div class="line">  hopCNO.addOffset(HopOffset::RIGHT_DOWN, <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(+1,-1,0));</div>
<div class="line">  hopCNO.addOffset(HopOffset::LEFT_UP,    <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(-1,+1,0));</div>
<div class="line">  hopCNO.addOffset(HopOffset::LEFT_DOWN,  <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(-1,-1,0));</div>
</div><!-- fragment --><p>The object <code>hopCNO</code> is a container of these offsets. In its constructor, it is passed the number of offsets that it will contain, which here is expressed as another enumeration constant, <code>HopOffset::SIZE</code>. The actual offsets are added with the <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html#a7b983204101cef4973f685d3c68a0106">KMCThinFilm::CellNeighOffsets::addOffset()</a>, which takes an integer label greater than zero and less than <code>HopOffset::SIZE</code>, and the offset itself. The integer label 0 (which is also <code>HopOffset::SELF</code>, a constant that will be seen later) is not used as an argument to <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html#a7b983204101cef4973f685d3c68a0106">KMCThinFilm::CellNeighOffsets::addOffset()</a> because it is reserved for the zero offset, i.e., <code>CellIndsOffset(0,0,0)</code>, which is automatically included in a <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html">KMCThinFilm::CellNeighOffsets</a> object. The offsets added in the snippet of code above correspond to the positions shown in the figure below:</p>
<div class="image">
<img src="OffsetsFractalSim.png" alt=""/>
</div>
 <p>Since the simulation is on a square lattice, <em>i</em> and <em>j</em> happen to be orthogonal, and the axis along which index <em>k</em> would point is perpendicularly out of the plane. Also, because this is a two-dimensional simulation, the third index of the offset, <em>k</em>, is always zero here.</p>
<p>Once the offsets are defined, cell-centered events can then be added:</p>
<div class="fragment"><div class="line">  sim.reserveCellCenteredEventGroups(1,FCellCenteredEvents::SIZE);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1EventExecutorGroup.html">EventExecutorGroup</a> hopExecs(FCellCenteredEvents::SIZE);</div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_LEFT,</div>
<div class="line">                            HoppingExecute(FCellCenteredEvents::HOP_LEFT));</div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_RIGHT,</div>
<div class="line">                            HoppingExecute(FCellCenteredEvents::HOP_RIGHT));</div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_UP,</div>
<div class="line">                            HoppingExecute(FCellCenteredEvents::HOP_UP));</div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_DOWN,</div>
<div class="line">                            HoppingExecute(FCellCenteredEvents::HOP_DOWN));</div>
<div class="line"> </div>
<div class="line">  sim.addCellCenteredEventGroup(1, hopCNO,</div>
<div class="line">                                HoppingPropensity(DoverF*F),</div>
<div class="line">                                hopExecs);</div>
</div><!-- fragment --><p>The member function <a class="el" href="classKMCThinFilm_1_1Simulation.html#a07827968543d9a9f2cbbdb356b5df8df">KMCThinFilm::Simulation::reserveCellCenteredEventGroups()</a> is somewhat analogous to the member function <a class="el" href="classKMCThinFilm_1_1Simulation.html#a21587717d5f10a6ae3b8c3606752db13">KMCThinFilm::Simulation::reserveOverLatticeEvents()</a> mentioned before. Unlike over-lattice events, though, similar types of cell-centered events are grouped together. The first argument to this function indicates the number of groups&mdash;which is just 1 in this case&mdash;while the second argument indicates the total number of individual cell-centered event types, regardless of grouping. Here, this number happens to be the enumeration constant <code>FCellCenteredEvents::SIZE</code>.</p>
<p>Before actually adding a group of cell-centered event types, an <a class="el" href="classKMCThinFilm_1_1EventExecutorGroup.html">KMCThinFilm::EventExecutorGroup</a> object must be constructed. This object encapsulates a set of functions or function objects used to execute one of the events in the group of event types, and its constructor takes as an argument the number of function/function objects to be added to the group. Functions and function objects are added to the group in a manner similar to the way offsets are added to a <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html">KMCThinFilm::CellNeighOffsets</a> object. Here, the <a class="el" href="classKMCThinFilm_1_1EventExecutorGroup.html#a109dab6bc920f3fd6cf7df5d8076a61f">KMCThinFilm::EventExecutorGroup::addEventExecutor()</a> takes two arguments: an integer label that is greater than or equal to zero and less than <code>FCellCenteredEvents::SIZE</code>, and a function/function object satisfying the <a class="el" href="namespaceKMCThinFilm.html#a601f0f23e6b591202d40f27df34db951">KMCThinFilm::EventExecutorAutoTrack</a> signature.</p>
<p>A group of cell-centered event types is added by means of the <a class="el" href="classKMCThinFilm_1_1Simulation.html#ada268bce065b942617fd1331b083626d">KMCThinFilm::Simulation::addCellCenteredEventGroup()</a> member function. This function takes four arguments: an integer label identifying the event, which is arbitrarily set to one, a <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html">KMCThinFilm::CellNeighOffsets</a> object, which here is <code>hopCNO</code>, a function or function object used to calculate the propensity of the event, which here is the object <code>HoppingPropensity(DoverF*F)</code>, and the aforementioned <a class="el" href="classKMCThinFilm_1_1EventExecutorGroup.html">KMCThinFilm::EventExecutorGroup</a> object. Here, the constructor for the <code>HoppingPropensity</code> function object class happens to take an argument equal to the hopping propensity <em>D</em>, but that will not necessarily be the case in general.</p>
<p>Finally, we define a time-periodic action, which here dumps the state of the lattice to a file at regular intervals of simulation time.</p>
<div class="fragment"><div class="line">  sim.reserveTimePeriodicActions(PAction::SIZE);</div>
<div class="line">  sim.addTimePeriodicAction(PAction::PRINT,</div>
<div class="line">                            PrintASCII(<span class="stringliteral">&quot;snapshot&quot;</span>),</div>
<div class="line">                            0.05*approxDepTime, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>Again, we have a member function for reserving a type of object, followed by a member function that adds the type of object. The argument to <a class="el" href="classKMCThinFilm_1_1Simulation.html#af30c7df97cb00c239325b0500b971a40">KMCThinFilm::Simulation::reserveTimePeriodicActions()</a> is the number of time-periodic actions to be added, and as before, this number is represented via an enumeration constant, <code>PAction::SIZE</code>. The member function <a class="el" href="classKMCThinFilm_1_1Simulation.html#a2d0b886ef44d3acf0a8c018a7042e1d9">KMCThinFilm::Simulation::addTimePeriodicAction()</a> has four arguments: an integer label, which here is another enumeration constant <code>PAction::PRINT</code>; a function object to execute the periodic action; the period for the action, which here is taken to be 0.05 &times; <code>approxDepTime</code>; and a Boolean flag to indicate if the action should be performed at the end of a simulation run.</p>
<p>After all this setup, the simulation is then actually set to run as follows:</p>
<div class="fragment"><div class="line">  sim.run(approxDepTime);</div>
<div class="line">  sim.removeOverLatticeEvent(FOverLatticeEvents::DEPOSITION);</div>
<div class="line">  sim.run(0.1*approxDepTime);</div>
</div><!-- fragment --><p>Note that the simulation is run in two stages. In the first stage, there is both diffusion and deposition for a certain amount of time. Then deposition is stopped by removing the deposition event from the simulation. In the second stage, the simulation is run with only diffusion.</p>
<p>(By the way, in this particular fractal model, since particles cannot diffuse if they have any nearest or next nearest neighbors, the simulation soon runs out of particles that can diffuse because the available particles soon acquire neighbors and thus become fixed in place. This causes the simulation to run out of possible events and end before the alloted simulation time is up.)</p>
<p>The general outline of the simulation, as indicated from the driver code, is as follows. First, a simulation object is initialized. Then, possible events and periodic actions are added to the simulation. Finally, the simulation is then run. There are still several &ldquo;blanks&rdquo; left. Some of these are the enumeration constants. Others are the details of the functions or function objects used to implement the possible events and periodic actions. For these, we turn to an examination of the implementation code in EventsAndActions.cpp and its associated header file.</p>
<h3><a class="anchor" id="ex_fractal_impl"></a>
Examining the implementation code</h3>
<p>We begin with the header file EventsAndActions.hpp. Here we see that the enumerations, rather than being defined directly, are generated from convenience macros defined in <a class="el" href="MakeEnum_8hpp.html" title="Defines convenience macros to set up enumeration constants for a KMC simulation.">MakeEnum.hpp</a> from the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library. These macros define enumerations associated with adding possible events and actions:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="MakeEnum_8hpp.html#a21a6e7611184f517474f1a4628e0e0cb">KMC_MAKE_ID_ENUM</a>(FOverLatticeEvents,</div>
<div class="line">                 DEPOSITION);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="MakeEnum_8hpp.html#a21a6e7611184f517474f1a4628e0e0cb">KMC_MAKE_ID_ENUM</a>(FCellCenteredEvents,</div>
<div class="line">                 HOP_UP,</div>
<div class="line">                 HOP_DOWN,</div>
<div class="line">                 HOP_LEFT,</div>
<div class="line">                 HOP_RIGHT);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="MakeEnum_8hpp.html#a21a6e7611184f517474f1a4628e0e0cb">KMC_MAKE_ID_ENUM</a>(PAction,</div>
<div class="line">                 PRINT);</div>
</div><!-- fragment --><p>The enumerations defined through these macros all include a constant containing the name &ldquo;<code>SIZE</code>&rdquo;, which indicates the number of constants in the enumeration (not including <code>SIZE</code> itself): <code>FOverLatticeEvents::SIZE</code>, <code>FCellCenteredEvents::SIZE</code>, and <code>PAction::SIZE</code>.</p>
<p>The following convenience macro operates similarly:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="MakeEnum_8hpp.html#ab74f47ea48cae4ae81e76e45c4fd67c4">KMC_MAKE_LATTICE_INTVAL_ENUM</a>(F, HEIGHT);</div>
</div><!-- fragment --><p>However, the prefix of the enumerations from this macro is not just the first argument of the macro, but the first argument plus &ldquo;<code>IntVal</code>, hence why the constant <code>FIntVal::SIZE</code> was seen in the driver code. This macro also defines the constant <code>FIntVal::HEIGHT</code>, which will be seen later in the implementation code.</p>
<p>The final macro invocation is</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="MakeEnum_8hpp.html#a18b06446141f866d52168964dbc824c7">KMC_MAKE_OFFSET_ENUM</a>(HopOffset,</div>
<div class="line">                     UP, DOWN, LEFT, RIGHT,</div>
<div class="line">                     RIGHT_UP, RIGHT_DOWN, LEFT_UP, LEFT_DOWN);</div>
</div><!-- fragment --><p>This defines the enumeration used to label the offsets between the cell about which an event is centered and the neighboring cells that affect its propensity. Unlike the previously defined enumerations, this one contains <em>two</em> special constants. One of them is <code>HopOffset::SIZE</code>, which as before is the number of constants in the enumeration (not including <code>SIZE</code> itself). We have seen this constant used in the driver code as the argument to a constructor of a <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html">KMCThinFilm::CellNeighOffsets</a> object. The other is <code>HopOffset::SELF</code>, which identifies <code><a class="el" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset(0,0,0)</a></code>, the offset corresponding to the cell about which an event is centered. This constant will be seen later in the implementation code.</p>
<p>The rest of the lines of the file <code>EventsAndActions.hpp</code> contain the declarations and definitions for the functions and function objects that define possible events and a periodic action. We now look at these and at their implementations in the file <code>EventsAndActions.cpp</code>.</p>
<p>Here is the declararation for the function performing deposition:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DepositionExecute(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a> &amp; ci,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">KMCThinFilm::SimulationState</a> &amp; simState,</div>
<div class="line">                       <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> &amp; lattice);</div>
</div><!-- fragment --><p>This function declaration satisfies the <a class="el" href="namespaceKMCThinFilm.html#a601f0f23e6b591202d40f27df34db951">KMCThinFilm::EventExecutorAutoTrack</a> signature, because it accepts arguments that are references to a <a class="el" href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a> object, a <a class="el" href="classKMCThinFilm_1_1SimulationState.html">KMCThinFilm::SimulationState</a> object, and a <a class="el" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> object, in that order. Furthermore, since this function is used to alter the lattice, the reference to the <a class="el" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> object is <em>not</em> constant. The implementation of this function is shown below. (It lacks the &ldquo;<code><a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a>::</code>&rdquo; prefix because <code>EventsAndActions.cpp</code> begins with the statement &ldquo;<code>using namespace <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a>;</code>&rdquo;.)</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DepositionExecute(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> &amp; ci,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">SimulationState</a> &amp; simState,</div>
<div class="line">                       <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">Lattice</a> &amp; lattice) {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> currVal = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ci, FIntVal::HEIGHT);</div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a81beda29c4c8722cb047f7f2ce0a09ce">setInt</a>(ci, FIntVal::HEIGHT, currVal + 1);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>The argument <code>ci</code> represents the <a class="el" href="classKMCThinFilm_1_1CellInds.html">indices of a lattice cell</a>. Since the function executes an <em>over-lattice</em> event, <code>ci.i</code> and <code>ci.j</code> are random values, and <code>ci.k</code> is one less than the current number of lattice planes&mdash;which for this two-dimensional simulation is simply zero. Essentially what is happening is that the column height at random location \((\mathtt{ci.i}, \mathtt{ci.j}, 0)\) in the lattice is being incremented by one.</p>
<p>In principle, this could have been implemented as class for a function <em>object</em>, that is, a class containing an overload of <code>operator()</code>, but here it is an ordinary function for the sake of simplicity. In some later examples, deposition <em>is</em> implemented by a function object class.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>simState</code> argument is not used in this case because the execution of this deposition event does not depend upon time. On the other hand, if, for example, deposition were on a rotating substrate, then it might be possible that deposition could occur along a trajectory whose azimuth was  \(2\pi\omega
\times \mathtt{simState.elapsedTime()}\), where \(\omega\) is the rate of rotation <a class="el" href="citelist.html#CITEREF_cho05">[3]</a>.</dd></dl>
<p>The function object class <code>HoppingPropensity</code> is defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>HoppingPropensity {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  HoppingPropensity(<span class="keywordtype">double</span> D) : D_(D) {}</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellNeighProbe &amp; cnp, </div>
<div class="line">                  std::vector&lt;double&gt; &amp; propensityVec) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">double</span> D_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In this class, the private data member <code>D_</code> stores the hopping propensity <em>D</em>. Also, this class satisfies the <a class="el" href="namespaceKMCThinFilm.html#afc58c6c4948aa7d7243beb0990a563f1">KMCThinFilm::CellCenteredGroupPropensities</a> signature, since it contains an overload of <code>operator()</code> that takes as arguments a constant reference to a <a class="el" href="classKMCThinFilm_1_1CellNeighProbe.html">KMCThinFilm::CellNeighProbe</a> object and <em>non</em>-constant reference to a <code>std::vector</code> of double precision values. This second argument is an output argument that will be the propensities of hopping in various directions. Before an instance of this function object class even has a chance to execute, the output argument will have already been resized so that it has the same number of elements as there are cell-centered events in the group associated with this function object class, and these elements will have been initialized to zero.</p>
<p>Here is the part of the implementation of the function object class that actually calculates the propensity for hopping:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> HoppingPropensity::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellNeighProbe.html">CellNeighProbe</a> &amp; cnp, </div>
<div class="line">                                   std::vector&lt;double&gt; &amp; propensityVec)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> currHeight = cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::SELF), FIntVal::HEIGHT);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (currHeight &gt; 0) {</div>
<div class="line">    <span class="keywordflow">if</span> ((currHeight &gt; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::UP), FIntVal::HEIGHT))</div>
<div class="line">        &amp;&amp; (currHeight &gt; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::DOWN), FIntVal::HEIGHT))</div>
<div class="line">        &amp;&amp; (currHeight &gt; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::LEFT), FIntVal::HEIGHT))</div>
<div class="line">        &amp;&amp; (currHeight &gt; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::RIGHT), FIntVal::HEIGHT))</div>
<div class="line">        &amp;&amp; (currHeight &gt; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::RIGHT_UP), FIntVal::HEIGHT))</div>
<div class="line">        &amp;&amp; (currHeight &gt; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::RIGHT_DOWN), FIntVal::HEIGHT))</div>
<div class="line">        &amp;&amp; (currHeight &gt; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::LEFT_UP), FIntVal::HEIGHT))</div>
<div class="line">        &amp;&amp; (currHeight &gt; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::LEFT_DOWN), FIntVal::HEIGHT))) {</div>
<div class="line"> </div>
<div class="line">      propensityVec[FCellCenteredEvents::HOP_LEFT] = </div>
<div class="line">        propensityVec[FCellCenteredEvents::HOP_RIGHT] = </div>
<div class="line">        propensityVec[FCellCenteredEvents::HOP_UP] = </div>
<div class="line">        propensityVec[FCellCenteredEvents::HOP_DOWN] = D_;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>In propensity calculations, access to the lattice is <em>indirect</em> and occurs via the <a class="el" href="classKMCThinFilm_1_1CellNeighProbe.html">KMCThinFilm::CellNeighProbe</a> object. This object can only access cells that can be returned by <a class="el" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">KMCThinFilm::CellNeighProbe::getCellToProbe</a>, which takes the integer label of an offset and returns an object that refers to the cell whose indices are the indices of the cell about which the event is centered plus that offset. If the cell indices about which an object is centered are \((i,j,k)\), then <code>getCellToProbe(HopOffset::UP)</code> returns an object referring to the cell with indices \((i,j+1,k)\), <code>getCellToProbe(HopOffset::DOWN)</code> returns an object referring to the cell with indices \((i,j-1,k)\), and so on. Also, <code>getCellToProbe(HopOffset::SELF)</code> returns an object referring to the cell about which the event is centered, that is, \((i,j,k)\).</p>
<dl class="section note"><dt>Note</dt><dd>The association of offsets with a <a class="el" href="namespaceKMCThinFilm.html#afc58c6c4948aa7d7243beb0990a563f1">KMCThinFilm::CellCenteredGroupPropensities</a> object is done in <a class="el" href="#ex_fractal_driver">driver code</a> via calls to <a class="el" href="classKMCThinFilm_1_1Simulation.html#ada268bce065b942617fd1331b083626d">KMCThinFilm::Simulation::addCellCenteredEventGroup()</a>.</dd></dl>
<p>The reason for using such indirect lattice access is that it forces the implementation of cell-centered propensity calculations to use well-defined local neighborhoods about the cell where an event is centered, which makes the incremental update of the set of possible events at each time step possible.</p>
<p>The actual propensity calculation itself is simple. The variable <code>currHeight</code> is the height of the column of particles at cell \((\mathtt{ci.i}, \mathtt{ci.j}, 0)\) in the true lattice. The propensities stored in <code>propensityVec</code> are already initially zero, so they only becomes equal to <code>D_</code> if</p>
<ul>
<li>the cell  \((\mathtt{ci.i}, \mathtt{ci.j}, \mathtt{currHeight} -
  1)\) in the true lattice is occupied (i.e. the column height stored at cell \((\mathtt{ci.i}, \mathtt{ci.j}, 0)\) of the computational lattice is nonzero), and</li>
<li>the lateral neighboring sites of cell  \((\mathtt{ci.i},
  \mathtt{ci.j}, \mathtt{currHeight} - 1)\) in the true lattice are empty (i.e. the column height stored at cell \((\mathtt{ci.i}, \mathtt{ci.j}, 0)\) in the computational lattice is greater than the column heights stored in the nearest and next-nearest neighbors of that cell).</li>
</ul>
<p>For convenience and ease of reading, the indices used with <code>propensityVec</code> are symbolic enumeration constants that correspond to an event type, i.e. <code>propensityVec[FCellCenteredEvents::HOP_LEFT]</code> is the propensity for hopping to the left, <code>propensityVec[FCellCenteredEvents::HOP_RIGHT]</code> is the propensity for hopping to the right, and so on.</p>
<dl class="section note"><dt>Note</dt><dd>Lattice indices start from zero, which is why the indices of the topmost particle of a column would be  \((\mathtt{ci.i},
\mathtt{ci.j}, \mathtt{currHeight} - 1)\), where <code>currHeight</code> is the height of the column of particles.</dd></dl>
<p>As a general rule, the propensity of an event centered at a cell should be zero if it cannot happen at that particular cell.</p>
<p>The function object class <code>HoppingExecute</code> is defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>HoppingExecute {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  HoppingExecute(FCellCenteredEvents::Type hopDir);</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellInds &amp; ci,</div>
<div class="line">                  <span class="keyword">const</span> KMCThinFilm::SimulationState &amp; simState,</div>
<div class="line">                  KMCThinFilm::Lattice &amp; lattice) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> jump_i_, jump_j_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This class satisfies the <a class="el" href="namespaceKMCThinFilm.html#a601f0f23e6b591202d40f27df34db951">KMCThinFilm::EventExecutorAutoTrack</a> signature, since it contains an overload of <code>operator()</code> that accepts arguments that are references to a <a class="el" href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a> object, a <a class="el" href="classKMCThinFilm_1_1SimulationState.html">KMCThinFilm::SimulationState</a> object, and a <a class="el" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> object, in that order. Again, since this operator is used to alter the lattice, the reference to the <a class="el" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> object is <em>not</em> constant. The constructor for this class is as follows:</p>
<div class="fragment"><div class="line">HoppingExecute::HoppingExecute(FCellCenteredEvents::Type hopDir) {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">switch</span> (hopDir) {</div>
<div class="line">  <span class="keywordflow">case</span> FCellCenteredEvents::HOP_UP:</div>
<div class="line">    jump_i_ = 0;</div>
<div class="line">    jump_j_ = 1;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> FCellCenteredEvents::HOP_DOWN:</div>
<div class="line">    jump_i_ = 0;</div>
<div class="line">    jump_j_ = -1;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> FCellCenteredEvents::HOP_LEFT:</div>
<div class="line">    jump_i_ = -1;</div>
<div class="line">    jump_j_ = 0;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">case</span> FCellCenteredEvents::HOP_RIGHT:</div>
<div class="line">    jump_i_ = 1;</div>
<div class="line">    jump_j_ = 0;</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">default</span>:</div>
<div class="line">    <a class="code hl_function" href="namespaceKMCThinFilm.html#a77bd0cec2abe3a269140d80cfea34ed8">exitWithMsg</a>(<span class="stringliteral">&quot;Bad hop direction!&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>One can see from this constructor that the function object it instantiates can do one of four possible events, namely a hop to one of four nearest neighboring cells.</p>
<p>Here is the part of the implementation of the function object class that actually executes the event:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> HoppingExecute::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> &amp; ci,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">SimulationState</a> &amp; simState,</div>
<div class="line">                                <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">Lattice</a> &amp; lattice)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ciTo(ci.i + jump_i_, ci.j + jump_j_, ci.k);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> currFrom = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ci, FIntVal::HEIGHT);</div>
<div class="line">  <span class="keywordtype">int</span> currTo = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ciTo, FIntVal::HEIGHT);</div>
<div class="line">  </div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a81beda29c4c8722cb047f7f2ce0a09ce">setInt</a>(ci, FIntVal::HEIGHT, currFrom - 1);</div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a81beda29c4c8722cb047f7f2ce0a09ce">setInt</a>(ciTo, FIntVal::HEIGHT, currTo + 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, <code>ci</code> is the set of indices of a cell where the cell-centered event can happen, rather than just some random location at the top of the lattice as it is for an over-lattice event. Since this particular model is two-dimensional, <code>ci.k</code> is always zero. The hopping of a particle from cell \((\mathtt{ci.i}, \mathtt{ci.j}, \mathtt{currFrom} - 1)\) in the true lattice to  \((\mathtt{ciTo.i}, \mathtt{ciTo.j},
\mathtt{currTo})\) is represented in the computational lattice as a decrement of the column height at <code>ci</code> and an increment of the column height at <code>ciTo</code>.</p>
<p>Finally, the function object class <code>PrintASCII</code>, which prints the state of the lattice to a text file, is defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PrintASCII {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  PrintASCII(<span class="keyword">const</span> std::string &amp; fNameRoot)</div>
<div class="line">    : fNameRoot_(fNameRoot),</div>
<div class="line">      snapShotCntr_(0)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::SimulationState &amp; simState,</div>
<div class="line">                  KMCThinFilm::Lattice &amp; lattice);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::string fNameRoot_;</div>
<div class="line">  <span class="keywordtype">int</span> snapShotCntr_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This code satisfies the function signature <a class="el" href="namespaceKMCThinFilm.html#ab48bbcbabdf454a07e2f0edb47404abe">KMCThinFilm::PeriodicAction</a>, since it takes as arguments references to a <a class="el" href="classKMCThinFilm_1_1SimulationState.html">KMCThinFilm::SimulationState</a> object and a <a class="el" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> object. While this particular periodic action only dumps the state of the lattice, it is possible for a periodic action to change the lattice, which is why the reference to the <a class="el" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> object is <em>not</em> constant.</p>
<p>Here is the implementation of the function object class:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> PrintASCII::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">SimulationState</a> &amp; simState, <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">Lattice</a> &amp; lattice) {</div>
<div class="line"> </div>
<div class="line">  ++snapShotCntr_;</div>
<div class="line"> </div>
<div class="line">  std::string fName = fNameRoot_ + boost::lexical_cast&lt;std::string&gt;(snapShotCntr_) + <span class="stringliteral">&quot;.dat&quot;</span>;</div>
<div class="line">    </div>
<div class="line">  std::ofstream outFile(fName.c_str());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structKMCThinFilm_1_1LatticePlanarBBox.html">LatticePlanarBBox</a> localPlanarBBox;</div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a1504ff860e046a8965b37dd437a74c52">getLocalPlanarBBox</a>(<span class="keyword">false</span>, localPlanarBBox);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> iminGlobal = localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a9de43623938e1ceb68c26feafd4cd009">imin</a>;</div>
<div class="line">  <span class="keywordtype">int</span> jminGlobal = localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#aa227140b560487687496bdbaef79d85e">jmin</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// &quot;P1&quot; here is short for &quot;Plus 1&quot;.</span></div>
<div class="line">  <span class="keywordtype">int</span> imaxP1Global = localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a8bc6629f20496b2845d66f924a04f35a">imaxP1</a>;</div>
<div class="line">  <span class="keywordtype">int</span> jmaxP1Global = localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#abedcda2c34e2bdfe0404e22838ed33dd">jmaxP1</a>;</div>
<div class="line"> </div>
<div class="line">  outFile &lt;&lt; <span class="stringliteral">&quot;# &quot;</span> &lt;&lt; iminGlobal &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; imaxP1Global &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; jminGlobal &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; jmaxP1Global</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot; time:&quot;</span> &lt;&lt; simState.<a class="code hl_function" href="classKMCThinFilm_1_1SimulationState.html#a01882b6444dedf12543e0a9e7f763f02">elapsedTime</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ci; ci.k = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (ci.i = localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a9de43623938e1ceb68c26feafd4cd009">imin</a>; ci.i &lt; localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a8bc6629f20496b2845d66f924a04f35a">imaxP1</a>; ++(ci.i)) {</div>
<div class="line">    <span class="keywordflow">for</span> (ci.j = localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#aa227140b560487687496bdbaef79d85e">jmin</a>; ci.j &lt; localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#abedcda2c34e2bdfe0404e22838ed33dd">jmaxP1</a>; ++(ci.j)) {</div>
<div class="line">      outFile &lt;&lt; ci.i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ci.j &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">              &lt;&lt; lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ci, FIntVal::HEIGHT) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  outFile.close();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This code prints a header that indicates the minimum and maximum values of in-plane lattice cell indices <em>i</em> and <em>j</em>, and the elapsed time. It then prints the in-plane indices of each cell and the column height stored at that cell.</p>
<p>Also, this code is written to in such a way as to facilitate parallelization. Since this is a serial code, <a class="el" href="classKMCThinFilm_1_1Lattice.html#ac160d406b29dc80fb72551ad3d74ac3a">KMCThinFilm::Lattice::getGlobalPlanarBBox()</a> could have been used in place of <a class="el" href="classKMCThinFilm_1_1Lattice.html#a1504ff860e046a8965b37dd437a74c52">KMCThinFilm::Lattice::getLocalPlanarBBox()</a> to obtain the minimum and maximum values of the in-plane indices. However, the code as written above will also work in parallel to produce a dump to a file of the part of the lattice that a given processor owns, which would <em>not</em> be true if <a class="el" href="classKMCThinFilm_1_1Lattice.html#ac160d406b29dc80fb72551ad3d74ac3a">KMCThinFilm::Lattice::getGlobalPlanarBBox()</a> had been used.</p>
<h3><a class="anchor" id="Results"></a>
Results</h3>
<p>An overhead view of the surface of the &ldquo;fractal&rdquo; thin film at various simulation times <em>t</em>, from 0.20 units to its maximum value of 4.0 units, is shown below. Within a given overhead view, black represents the smallest possible height of a column of particles, and white represents the largest.</p>
<div class="image">
<img src="testFractalSnapshots.png" alt=""/>
</div>
 <h2><a class="anchor" id="ex_fractal_sman_tracking"></a>
Using semi-manual tracking</h2>
<p>The code for this example, which is in the directory <code>doc/example-code/testFractal_semi_manual_track</code> of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> installation, is not much different from that used for previous section &ldquo;<a class="el" href="#ex_fractal_auto_tracking">Using auto-tracking</a>.&rdquo;</p>
<p>The source code for the driver file, <code>testFractal.cpp</code>, mainly differs in how event types are added to the system. The following code is used to add the over-lattice event type of deposition to the simulation:</p>
<div class="fragment"><div class="line">  std::vector&lt;CellNeighOffsets&gt; tmpExecCNO;</div>
<div class="line">  tmpExecCNO.reserve(1);</div>
<div class="line"> </div>
<div class="line">  sim.reserveOverLatticeEvents(FOverLatticeEvents::SIZE);</div>
<div class="line"> </div>
<div class="line">  tmpExecCNO.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellNeighOffsets.html">CellNeighOffsets</a>(1));</div>
<div class="line">  sim.reserveOverLatticeEvents(FOverLatticeEvents::SIZE);</div>
<div class="line">  sim.addOverLatticeEvent(FOverLatticeEvents::DEPOSITION,</div>
<div class="line">                          F, DepositionExecute, tmpExecCNO);</div>
</div><!-- fragment --><p>The member function <a class="el" href="classKMCThinFilm_1_1Simulation.html#a21587717d5f10a6ae3b8c3606752db13">KMCThinFilm::Simulation::reserveOverLatticeEvents()</a> works the same as before. What differs is the member function <a class="el" href="classKMCThinFilm_1_1Simulation.html#affa3dff53afd248546457944b98376d9">KMCThinFilm::Simulation::addOverLatticeEvent()</a>, which now has an additional argument, <code>tmpExecCNO</code>, a <code>std::vector</code> of <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html">KMCThinFilm::CellNeighOffsets</a> objects. For a given deposition event, only one lattice cell is directly changed, so <code>tmpExecCNO</code> has only one element, which in turn contains only one <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html">KMCThinFilm::CellNeighOffsets</a> instance, which contains only the offset that is present in every such instance, \((0,0,0)\). The third argument of <a class="el" href="classKMCThinFilm_1_1Simulation.html#affa3dff53afd248546457944b98376d9">KMCThinFilm::Simulation::addOverLatticeEvent()</a> is also different, since it satisfies the <a class="el" href="namespaceKMCThinFilm.html#a92a9e6c3ced8703f95265e85d80f1797">KMCThinFilm::EventExecutorSemiManualTrack</a> signature rather than the <a class="el" href="namespaceKMCThinFilm.html#a601f0f23e6b591202d40f27df34db951">KMCThinFilm::EventExecutorAutoTrack</a> signature. The following code is used to add a group of cell-centered event types:</p>
<div class="fragment"><div class="line">  sim.reserveCellCenteredEventGroups(1,FCellCenteredEvents::SIZE);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1EventExecutorGroup.html">EventExecutorGroup</a> hopExecs(FCellCenteredEvents::SIZE);</div>
<div class="line">  tmpExecCNO.clear();</div>
<div class="line">  tmpExecCNO.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellNeighOffsets.html">CellNeighOffsets</a>(2));</div>
<div class="line">  tmpExecCNO.back().addOffset(1, hopCNO.getOffset(HopOffset::LEFT));</div>
<div class="line"> </div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_LEFT,</div>
<div class="line">                            HoppingExecute(), tmpExecCNO);</div>
<div class="line"></div>
<div class="line">  tmpExecCNO.back().resetOffsets(2);</div>
<div class="line">  tmpExecCNO.back().addOffset(1, hopCNO.getOffset(HopOffset::RIGHT));</div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_RIGHT,</div>
<div class="line">                            HoppingExecute(), tmpExecCNO);</div>
<div class="line"> </div>
<div class="line">  tmpExecCNO.back().resetOffsets(2);</div>
<div class="line">  tmpExecCNO.back().addOffset(1, hopCNO.getOffset(HopOffset::UP));</div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_UP,</div>
<div class="line">                            HoppingExecute(), tmpExecCNO);</div>
<div class="line"> </div>
<div class="line">  tmpExecCNO.back().resetOffsets(2);</div>
<div class="line">  tmpExecCNO.back().addOffset(1, hopCNO.getOffset(HopOffset::DOWN));</div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_DOWN,</div>
<div class="line">                            HoppingExecute(), tmpExecCNO);</div>
<div class="line"> </div>
<div class="line">  sim.addCellCenteredEventGroup(1, hopCNO,</div>
<div class="line">                                HoppingPropensity(DoverF*F),</div>
<div class="line">                                hopExecs);</div>
</div><!-- fragment --><p>Here, the member functions <a class="el" href="classKMCThinFilm_1_1Simulation.html#a07827968543d9a9f2cbbdb356b5df8df">KMCThinFilm::Simulation::reserveCellCenteredEventGroups()</a> and <a class="el" href="classKMCThinFilm_1_1Simulation.html#ada268bce065b942617fd1331b083626d">KMCThinFilm::Simulation::addCellCenteredEventGroup()</a> are the same as before. What differs is the way entries are added to the <a class="el" href="classKMCThinFilm_1_1EventExecutorGroup.html">KMCThinFilm::EventExecutorGroup</a> instance. Here, <a class="el" href="classKMCThinFilm_1_1EventExecutorGroup.html#a109dab6bc920f3fd6cf7df5d8076a61f">KMCThinFilm::EventExecutorGroup::addEventExecutor()</a> takes an additional argument, the vector <code>tmpExecCNO</code>. This vector still contains a single element each time it is used, but since a hopping event changes two lattice cells, this single element contains a <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html">KMCThinFilm::CellNeighOffsets</a> instance with two offsets: the ever-present offset \((0,0,0)\), corresponding to the cell from which a particle hops, and an offset corresponding to the cell to which a particle hops, which depends on the hopping direction. The second argument to <a class="el" href="classKMCThinFilm_1_1EventExecutorGroup.html#a109dab6bc920f3fd6cf7df5d8076a61f">KMCThinFilm::EventExecutorGroup::addEventExecutor()</a> is also different, since it satisfies the <a class="el" href="namespaceKMCThinFilm.html#a92a9e6c3ced8703f95265e85d80f1797">KMCThinFilm::EventExecutorSemiManualTrack</a> signature rather than the <a class="el" href="namespaceKMCThinFilm.html#a601f0f23e6b591202d40f27df34db951">KMCThinFilm::EventExecutorAutoTrack</a> signature.</p>
<p>In <code>EventsAndActions.hpp</code>, here is the declararation for the function performing deposition:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DepositionExecute(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a> &amp; ci,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">KMCThinFilm::SimulationState</a> &amp; simState,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> &amp; lattice,</div>
<div class="line">                       std::vector&lt;KMCThinFilm::CellsToChange&gt; &amp; ctcVec);</div>
</div><!-- fragment --><p>This function declaration satisfies the <a class="el" href="namespaceKMCThinFilm.html#a92a9e6c3ced8703f95265e85d80f1797">KMCThinFilm::EventExecutorSemiManualTrack</a> signature, because it accepts arguments that are references to a <a class="el" href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a> object, a <a class="el" href="classKMCThinFilm_1_1SimulationState.html">KMCThinFilm::SimulationState</a> object, a <a class="el" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> object, and a <code>std::vector</code> of <a class="el" href="classKMCThinFilm_1_1CellsToChange.html">KMCThinFilm::CellsToChange</a> objects, in that order. Here, the reference to the <a class="el" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> object <em>is</em> constant, since changes to the lattice are forced to occur via <a class="el" href="classKMCThinFilm_1_1CellsToChange.html">KMCThinFilm::CellsToChange</a> objects. The implementation of this function is shown below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DepositionExecute(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> &amp; ci,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">SimulationState</a> &amp; simState,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> &amp; lattice,</div>
<div class="line">                       std::vector&lt;KMCThinFilm::CellsToChange&gt; &amp; ctcVec) {</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellsToChange.html">CellsToChange</a> &amp; ctc = ctcVec[0];</div>
<div class="line">  ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#a8a56c1106701d5bc3409cd30343fee2c">setCenter</a>(ci);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> currVal = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ci, FIntVal::HEIGHT);</div>
<div class="line">  ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#a62079b840cc200e37e2907ba2e394f78">setInt</a>(0, FIntVal::HEIGHT, currVal + 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In general, a <a class="el" href="classKMCThinFilm_1_1CellsToChange.html">KMCThinFilm::CellsToChange</a> object contains a set of offsets that specifies the relative positions of changed cells, and the <a class="el" href="classKMCThinFilm_1_1CellsToChange.html#a8a56c1106701d5bc3409cd30343fee2c">KMCThinFilm::CellsToChange::setCenter()</a> member function essentially provides an &ldquo;anchor&rdquo; used to translate these relative positions to absolute ones. Given a center  \((i_0,
j_0, k_0)\) and offsets \((0,0,0)\), \((o^1_i,o^1_j,o^1_k)\), etc., the absolute coordinates of the cells to change become \((i_0, j_0, k_0)\),  \((i_0 + o^1_i, j_0 + o^1_j, k_0 +
o^1_k)\), etc. Because of how this over-lattice event was set up in the driver code, the <a class="el" href="classKMCThinFilm_1_1CellsToChange.html">KMCThinFilm::CellsToChange</a> object here happens to contain only one offset, \((0,0,0)\), the indices of the cell to be changed are just  \((\mathtt{ci.i}, \mathtt{ci.j},
\mathtt{ci.k})\). The member function <a class="el" href="classKMCThinFilm_1_1CellsToChange.html#a62079b840cc200e37e2907ba2e394f78">KMCThinFilm::CellsToChange::setInt()</a> performs the actual change to the cell. This member function is analogous to <a class="el" href="classKMCThinFilm_1_1Lattice.html#a81beda29c4c8722cb047f7f2ce0a09ce">KMCThinFilm::Lattice::setInt()</a>, except that its first argument is an integer ID corresponding to one of the offsets stored in a <a class="el" href="classKMCThinFilm_1_1CellsToChange.html">KMCThinFilm::CellsToChange</a> object, rather than a set of cell indices. An integer ID of zero always corresponds to the offset \((0,0,0)\), and accordingly to the indices of the center, which here is \((\mathtt{ci.i}, \mathtt{ci.j}, \mathtt{ci.k})\).</p>
<p>The function object class <code>HoppingExecute</code> is now defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>HoppingExecute {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellInds &amp; ci,</div>
<div class="line">                  <span class="keyword">const</span> KMCThinFilm::SimulationState &amp; simState,</div>
<div class="line">                  <span class="keyword">const</span> KMCThinFilm::Lattice &amp; lattice,</div>
<div class="line">                  std::vector&lt;KMCThinFilm::CellsToChange&gt; &amp; ctcVec) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Since semi-manual tracking is used, this class satisfies the <a class="el" href="namespaceKMCThinFilm.html#a92a9e6c3ced8703f95265e85d80f1797">KMCThinFilm::EventExecutorSemiManualTrack</a> signature, rather than the <a class="el" href="namespaceKMCThinFilm.html#a601f0f23e6b591202d40f27df34db951">KMCThinFilm::EventExecutorAutoTrack</a> signature. Unlike the previous implementation of the <code>HoppingExecute</code> class, this one has no private members to indicate the hopping direction, because the hopping direction is determined from the <code>ctcVec</code> argument. Here is the part of the implementation of the function object class that actually executes the event:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> HoppingExecute::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> &amp; ci,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">SimulationState</a> &amp; simState,</div>
<div class="line">                                <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> &amp; lattice,</div>
<div class="line">                                std::vector&lt;KMCThinFilm::CellsToChange&gt; &amp; ctcVec)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellsToChange.html">CellsToChange</a> &amp; ctc = ctcVec[0];</div>
<div class="line">  ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#a8a56c1106701d5bc3409cd30343fee2c">setCenter</a>(ci);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> currFrom = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ci, FIntVal::HEIGHT);</div>
<div class="line">  <span class="keywordtype">int</span> currTo = ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#ae559a33ad8206a5e1c8cfd8803ccc765">getInt</a>(1, FIntVal::HEIGHT);</div>
<div class="line">  </div>
<div class="line">  ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#a62079b840cc200e37e2907ba2e394f78">setInt</a>(0, FIntVal::HEIGHT, currFrom - 1);</div>
<div class="line">  ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#a62079b840cc200e37e2907ba2e394f78">setInt</a>(1, FIntVal::HEIGHT, currTo + 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, <code>ctcVec</code> contains a <a class="el" href="classKMCThinFilm_1_1CellsToChange.html">KMCThinFilm::CellsToChange</a> object with <em>two</em> offsets: \((0,0,0)\), which corresponds to the cell from which a particle hops, and an offset that corresponds to the cell to which a particle hops, which depends on the hopping direction. Here we see <a class="el" href="classKMCThinFilm_1_1CellsToChange.html#ae559a33ad8206a5e1c8cfd8803ccc765">KMCThinFilm::CellsToChange::getInt()</a> as well as <a class="el" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">KMCThinFilm::Lattice::getInt()</a>. The former function is analogous to the latter, with the former function using an integer ID&mdash;corresponding to one of the offsets in a <a class="el" href="classKMCThinFilm_1_1CellsToChange.html">KMCThinFilm::CellsToChange</a> object&mdash;instead of cell indices. The integer ID of offset \((0,0,0)\) is, as always,</p><ol type="1">
<li>The integer ID of the other offset can be inferred from the portion of the driver code where the offset was set. For example, for rightward hopping, the code to set the offset is</li>
</ol>
<div class="fragment"><div class="line">  tmpExecCNO.back().resetOffsets(2);</div>
<div class="line">  tmpExecCNO.back().addOffset(1, hopCNO.getOffset(HopOffset::RIGHT));</div>
<div class="line">  hopExecs.addEventExecutor(FCellCenteredEvents::HOP_RIGHT,</div>
<div class="line">                            HoppingExecute(), tmpExecCNO);</div>
</div><!-- fragment --><p>The first argument of <a class="el" href="classKMCThinFilm_1_1CellNeighOffsets.html#a7b983204101cef4973f685d3c68a0106">KMCThinFilm::CellNeighOffsets::addOffset()</a>, which here happens to be 1, is the integer ID for the offset corresponding to the cell to which a particle hops.</p>
<p>The rest of the code of this implementation of a fractal solid-on-solid model is the same as it is in <a class="el" href="#ex_fractal_auto_tracking">the implementation using auto-tracking</a>.</p>
<h1><a class="anchor" id="example_fractal_par"></a>
Example: Parallelizing an implementation of a &ldquo;fractal&rdquo; solid-on-solid model</h1>
<p>The code for this example is in the directory <code>doc/example-code/testFractal_parallel</code> of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> installation, and it is almost the same as that in <code>doc/example-code/testFractal_semi_manual_track</code>. Some of the most pertinent differences between the two codes will be discussed here. The parallelized code is actually written so that it can be compiled to either a serial application or an MPI application.</p>
<p>The actual process of parallelizing the code described in the previous section is actually straightforward. Only the driver code, in <code>testFractal.cpp</code> differs from its serial counterpart, though if the code for dumping the state of the lattice to a file had been different, this might not have been the case. The most obvious changes are near the beginning and the end of the function <code>main()</code>, where <code>MPI_Init()</code> and <code>MPI_Finalize() are called</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if KMC_PARALLEL</span></div>
<div class="line">  MPI_Init(&amp;argc, &amp;argv);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#if KMC_PARALLEL</span></div>
<div class="line">  MPI_Finalize();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>In order for the driver code to be compilable as serial code, these MPI calls are wrapped by the <code>#if KMC_PARALLEL</code> and <code>#endif</code> preprocessor directives. Note that <code>#if</code> and <b>not</b> <code>#ifdef</code> is used here.</p>
<p>While most of the parameters near the beginning of <code>main()</code> are the same as in the serial version of the code, there is one minor change and one addition, which can be seen below.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> F = 1, DoverF = 1e5, maxCoverage = 4;</div>
<div class="line">  <span class="keywordtype">int</span> domainSize = 256;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> seedGlobal = 42;</div>
<div class="line">  <a class="code hl_enumeration" href="namespaceKMCThinFilm_1_1SolverId.html#a43b0b7ee9ab985e86a13450beb2c7523">SolverId::Type</a> sId = <a class="code hl_enumvalue" href="namespaceKMCThinFilm_1_1SolverId.html#a43b0b7ee9ab985e86a13450beb2c7523a66b6c59bbaeb00525c6dd96af1b33563">SolverId::DYNAMIC_SCHULZE</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1TimeIncr_1_1SchemeVars.html">TimeIncr::SchemeVars</a> schemeVars;</div>
<div class="line">  schemeVars.<a class="code hl_function" href="classKMCThinFilm_1_1TimeIncr_1_1SchemeVars.html#a9c534dc3967fe996205a22d3b4eb9efc">setSchemeName</a>(<a class="code hl_enumvalue" href="namespaceKMCThinFilm_1_1TimeIncr_1_1SchemeName.html#a9d8be73a26298e6c4379c28285902534ad72ce3a3804cccdfc67fd4debe9cfe9c">TimeIncr::SchemeName::MAX_AVG_PROPENSITY_PER_POSS_EVENT</a>);</div>
<div class="line"> </div>
<div class="line">  schemeVars.<a class="code hl_function" href="classKMCThinFilm_1_1TimeIncr_1_1SchemeVars.html#a791374d98d976927c656d4adabe19f8d">setSchemeParam</a>(<a class="code hl_enumvalue" href="namespaceKMCThinFilm_1_1TimeIncr_1_1SchemeParam.html#a1ee2f5f6234ea51c6d8ae6993aee48caa1434deeb490996399bdff45a7eb194ee">TimeIncr::SchemeParam::NSTOP</a>, </div>
<div class="line">#ifndef BAD_NSTOP</div>
<div class="line">                            1</div>
<div class="line">#<span class="keywordflow">else</span></div>
<div class="line">                            100</div>
<div class="line">#endif</div>
<div class="line">                            );</div>
</div><!-- fragment --><p>The minor change is just a renaming of the variable <code>seed</code> to <code>seedGlobal</code>, which reflects a change in how the random number generator is initialized in parallel. The addition is the presence of an instance of <a class="el" href="classKMCThinFilm_1_1TimeIncr_1_1SchemeVars.html">KMCThinFilm::TimeIncr::SchemeVars</a>, which is used to set the choice of parallel time stepping scheme and any parameter of it. A choice of such a scheme is required to run a parallel Kinetic Monte Carlo simulation. (Parallel time stepping is discussed in the section entitled &ldquo;<a class="el" href="concepts_and_algorithms.html#kmc_par_alg">Parallel approximate Kinetic Monte Carlo algorithm</a>.&rdquo;) The preprocessor variable <code>BAD_NSTOP</code> is used in this example to determine whether the parameter \(n_{stop}\) for the parallel time stepping is set to a reasonable value for this simulation, or to one that will produce artifacts.) Unlike the calls to MPI functions, this addition does not have to be placed between <code>#if KMC_PARALLEL</code> and <code>#endif</code> directives. It simply has no effect in a serial simulation. This is a common practice in the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library. Unless a part of its programming interface explicitly involves an MPI data structure, such as <code>MPI_Comm</code>, it will be both legal and harmless in serial code.</p>
<p>Most of the initialization of the simulation, which is shown here,</p>
<div class="fragment"><div class="line">  <a class="code hl_struct" href="structKMCThinFilm_1_1LatticeParams.html">LatticeParams</a> latParams;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a7a9d46d27758a276fd20d9c18156371a">numIntsPerCell</a> = FIntVal::SIZE;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3a3cc62a6fb5fdda00ed2c63e1ff1020">globalPlanarDims</a>[0] = latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3a3cc62a6fb5fdda00ed2c63e1ff1020">globalPlanarDims</a>[1] = domainSize;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#addb121738727b46ba00c2c71996f4272">ghostExtent</a>[0] = latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#addb121738727b46ba00c2c71996f4272">ghostExtent</a>[1] = 1;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef USE_COMPACT_DECOMP</span></div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a02f5a1a7568e0d94d0127260b4e9dd05">parallelDecomp</a> = <a class="code hl_enumvalue" href="structKMCThinFilm_1_1LatticeParams.html#ad3f37769b5b30a8f3e941743271def8aa8fc91ae7961264b3e4b8a0706bc01968">LatticeParams::COMPACT</a>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1Simulation.html">Simulation</a> sim(latParams);</div>
</div><!-- fragment --><p>is the same as in the serial simulation, except for a crucial addition: specifying the values of the <code>ghostExtent</code> member of the <a class="el" href="structKMCThinFilm_1_1LatticeParams.html">KMCThinFilm::LatticeParams</a> object, which indicate the extent of the ghost region at the edge of each lattice plane. As with the reference to <a class="el" href="classKMCThinFilm_1_1TimeIncr_1_1SchemeVars.html">KMCThinFilm::TimeIncr::SchemeVars</a>, there is no need to wrap the statement <code>latParams.ghostExtent[0] = latParams.ghostExtent[1] = 1</code> within <code>#if KMC_PARALLEL</code> and <code>#endif</code>, since it simply has no effect in a serial simulation. The preprocessor variable <code>USE_COMPACT_DECOMP</code> is used in this example to determine whether compact parallel decomposition is used instead of the default row-based decomposition. (See the section entitled &ldquo;<a class="el" href="concepts_and_algorithms.html#kmc_par_alg">Parallel approximate Kinetic Monte Carlo algorithm</a>""&rdquo; for a description of methods of decomposition.)</p>
<p>Also, in a parallel simulation, the <a class="el" href="structKMCThinFilm_1_1LatticeParams.html">KMCThinFilm::LatticeParams</a> object has an additional member of type <code>MPI_Comm</code>, <code>latticeCommInitial</code>. By default, this is simply set to <code>MPI_COMM_WORLD</code>, so there is typically no need to explicitly specify it. However, since it is not defined in the serial version of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library, if there had been any explicit reference to it in the driver code, it would have needed to have been surrounded by <code>#if KMC_PARALLEL</code> and <code>#endif</code>.</p>
<p>Setting the random number generator becomes slightly more complicated in a parallel simulation, as shown below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if KMC_PARALLEL</span></div>
<div class="line">  <a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">RandNumGenSharedPtr</a> rng(<span class="keyword">new</span> <a class="code hl_class" href="classKMCThinFilm_1_1RandNumGenDCMT.html">RandNumGenDCMT</a>(sim.procID(),</div>
<div class="line">                                             seedGlobal,</div>
<div class="line">                                             123*sim.procID() + 456,</div>
<div class="line">                                             RandNumGenDCMT::P521));</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">RandNumGenSharedPtr</a> rng(<span class="keyword">new</span> <a class="code hl_class" href="classKMCThinFilm_1_1RandNumGenMT19937.html">RandNumGenMT19937</a>(seedGlobal));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">  sim.setRNG(rng);</div>
</div><!-- fragment --><p>Here, in the serial version of the code, the <a class="el" href="classKMCThinFilm_1_1RandNumGenMT19937.html">KMCThinFilm::RandNumGenMT19937</a> is used, while in parallel, <a class="el" href="classKMCThinFilm_1_1RandNumGenDCMT.html">KMCThinFilm::RandNumGenDCMT</a> is used. In principle, <a class="el" href="classKMCThinFilm_1_1RandNumGenDCMT.html">KMCThinFilm::RandNumGenDCMT</a> could be have been used for both parallel and serial, but <a class="el" href="classKMCThinFilm_1_1RandNumGenMT19937.html">KMCThinFilm::RandNumGenMT19937</a> is restricted to serial use. One should also note that the constructor to parallel random number generators such as <a class="el" href="classKMCThinFilm_1_1RandNumGenDCMT.html">KMCThinFilm::RandNumGenDCMT</a> takes the MPI rank or processor ID as an argument. Here, this is given by <a class="el" href="classKMCThinFilm_1_1Simulation.html#a4007433a9f7d97dd149c2488b7d94e5b">KMCThinFilm::Simulation::procID()</a>.</p>
<p>Once <a class="el" href="classKMCThinFilm_1_1Simulation.html#adf613f2cf2520695a0fb2ddbbdfd2328">KMCThinFilm::Simulation::setSolver()</a> has been called, the parallel time step scheme can now be set as follows.</p>
<div class="fragment"><div class="line">  sim.setTimeIncrScheme(schemeVars);</div>
</div><!-- fragment --><p>Again, there is no need to surround this by <code>#if KMC_PARALLEL</code> and <code>#endif</code>, since it is just a no-op in serial code.</p>
<p>Finally, there is a minor but needed change in the setup for dumping the state of the lattice to files:</p>
<div class="fragment"><div class="line">  sim.reserveTimePeriodicActions(PAction::SIZE);</div>
<div class="line">  sim.addTimePeriodicAction(PAction::PRINT,</div>
<div class="line">                            PrintASCII(<span class="stringliteral">&quot;outFile_ProcCoords&quot;</span> + </div>
<div class="line">                                       boost::lexical_cast&lt;std::string&gt;(sim.commCoord(0)) + <span class="stringliteral">&quot;_&quot;</span> +</div>
<div class="line">                                       boost::lexical_cast&lt;std::string&gt;(sim.commCoord(1)) + <span class="stringliteral">&quot;_snapshot&quot;</span>),</div>
<div class="line">                            0.05*approxDepTime, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>Whereas before in the purely serial code, the root of the names of the dump files was just &ldquo;<code>snapshot</code>&rdquo;, now it is a string that is unique to each MPI process. Here, each process writes to its own file, which is not always optimal but will suffice here. In serial code, <code>sim.commCoord(0)</code> and <code>sim.commCoord(1)</code> both return an integer value of zero.</p>
<p>When running the parallelized code, two things may be noticed. First, for such a small simulation, it is likely to run <em>slower</em> than the corresponding serial code. Second, whereas the serial code will simply quit when it runs out of possible events to execute, the parallel code will simply continue until the specified simulation time is reached.</p>
<p>The results of the parallel simulations should be about the same as those in the serial simulation, provided that the parameters for the parallel time stepping algorithm are set appropriately. The following results show what may happen if they are not set correctly:</p>
<div class="image">
<img src="testParBadSnapshots.png" alt=""/>
</div>
 <p>These snapshots of the simulated surface, at simulations times <em>t</em> 1.0 through 4.0, contain artifacts that have been described as a &ldquo;shish-kebob&rdquo; effect <a class="el" href="citelist.html#CITEREF_plim23">[7]</a>, where parts of the growing simulated film concentrate on sector boundaries. Some instances of these artifacts have been circled in red. The presence of these artifacts indicates that the size of the parallel time steps is too large.</p>
<h1><a class="anchor" id="example_baldep"></a>
Example: Implementations of a ballistic deposition model</h1>
<p>While the examples above showcased several features of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library, they were still two-dimensional. This particular example is meant to show what is needed for a simulation that requires a three-dimensional lattice. It will also show a few other features of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library.</p>
<p>What follows is a pair of example implementations that involve ballistic deposition on a cubic lattice and a contrived cell-centered event to change the &ldquo;color&rdquo; of a lattice cell, which here is a floating-point number between zero and one. In ballistic deposition, a depositing particle travels in a straight line until it is close enough to another particle to &ldquo;stick&rdquo; to it. The result is a deposit that can have several vacancies and overhangs. For simplicity, the depositing particles travel straight downward, which allows the use of simplified algorithms that obviate the need to explicitly model the actual travel of the particle. The propensity of the cell-centered event is proportional to the number of occupied nearest neighbors of a lattice cell, including those above and below the cell, and the execution of the event changes the color to an average of the the current cell color and the colors of its occupied nearest neighbors.</p>
<p>In the simplified deposition algorithm <a class="el" href="citelist.html#CITEREF_meakin92">[6]</a>, there is both a cubic lattice, whose cells may either be occupied or unoccupied, and an auxiliary two-dimensional array of active zone height coordinates, which has the same lateral dimensions as the cubic lattice and may be denoted as \(h_a(i,j)\). Before any deposition events begin, the elements of \(h_a(i,j)\) are initialized to zero. When a deposition event is chosen, in-plane lattice coordinates \((i,j)\) are randomly chosen. Then, a particle is placed at lattice site  \(\left(i,j,
h_a(i,j)\right)\), and for each in-plane coordinate  \((i_{neigh}, j_{neigh}) \in \{(i+1,j), (i-1,j), (i,j+1),
(i,j-1)\}\), the value of \(h_a(i_{neigh}, j_{neigh})\) is checked to see if is less than \(h_a(i,j)\). If it is, then it is increased it to the value of \(h_a(i,j)\). After this, \(h_a(i,j)\) is incremented by one.</p>
<h2><a class="anchor" id="example_baldep_impl1"></a>
First implementation</h2>
<p>The code for this implementation is in <code>doc/example-code/testBallisticDep1</code> of the installation directory of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library. In this implementation, auto-tracking has been used. Also, the values of the auxiliary array \(h_a(i,j)\) are stored within the first plane of the lattice. Accordingly, in <code>EventsAndActions.hpp</code>, the following enumeration,</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="MakeEnum_8hpp.html#ab74f47ea48cae4ae81e76e45c4fd67c4">KMC_MAKE_LATTICE_INTVAL_ENUM</a>(BD, IS_OCCUPIED, ACTIVE_ZONE_HEIGHT);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="MakeEnum_8hpp.html#aa5359f8f13cbe2c11d54214f49fcf8e8">KMC_MAKE_LATTICE_FLOATVAL_ENUM</a>(BD, COLOR);</div>
</div><!-- fragment --><p>has been defined. The definition for the function object class defining deposition is as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DepositionExecute {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  DepositionExecute();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellInds &amp; ci,</div>
<div class="line">                  <span class="keyword">const</span> KMCThinFilm::SimulationState &amp; simState,</div>
<div class="line">                  KMCThinFilm::Lattice &amp; lattice);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::vector&lt;KMCThinFilm::CellIndsOffset&gt; neighOffsets_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The vector <code>neighOffsets_</code> will be used to find the in-plane neighboring lattice cells of the randomly chosen deposition site. This vector is now initialized in the constructor for the deposition function object:</p>
<div class="fragment"><div class="line">DepositionExecute::DepositionExecute() {</div>
<div class="line">  </div>
<div class="line">  neighOffsets_.reserve(4);</div>
<div class="line">  neighOffsets_.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>( 0,-1));</div>
<div class="line">  neighOffsets_.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>( 0,+1));</div>
<div class="line">  neighOffsets_.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(-1, 0));</div>
<div class="line">  neighOffsets_.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(+1, 0));</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>The implementation of the operator that performs the actual execution of the deposition event is shown below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DepositionExecute::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> &amp; ci,</div>
<div class="line">                                   <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">SimulationState</a> &amp; simState,</div>
<div class="line">                                   <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">Lattice</a> &amp; lattice) {</div>
<div class="line">  </div>
<div class="line">  <span class="comment">/* Ballistic deposition algorithm for cubic lattices from Meakin and</span></div>
<div class="line"><span class="comment">     Krug, Physical Review A, vol. 46, num. 6, pp. 3390-3399 (1992).*/</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ciInPlane(ci.i, ci.j, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> kDepAtom = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ciInPlane, BDIntVal::ACTIVE_ZONE_HEIGHT);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ciTo(ci.i, ci.j, kDepAtom);</div>
<div class="line">  </div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aa36bda22ed2b0bc8d8737d3d63009765">addPlanes</a>(ciTo.k - ci.k);</div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a81beda29c4c8722cb047f7f2ce0a09ce">setInt</a>(ciTo, BDIntVal::IS_OCCUPIED, 1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::vector&lt;CellIndsOffset&gt;::const_iterator offsetItr = neighOffsets_.begin(),</div>
<div class="line">         offsetItrEnd = neighOffsets_.end(); offsetItr != offsetItrEnd; ++offsetItr) {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> neighInPlane = ciInPlane + *offsetItr;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(neighInPlane, BDIntVal::ACTIVE_ZONE_HEIGHT) &lt; kDepAtom) {</div>
<div class="line">      lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a81beda29c4c8722cb047f7f2ce0a09ce">setInt</a>(neighInPlane, BDIntVal::ACTIVE_ZONE_HEIGHT, kDepAtom);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a81beda29c4c8722cb047f7f2ce0a09ce">setInt</a>(ciInPlane, BDIntVal::ACTIVE_ZONE_HEIGHT, kDepAtom + 1);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Again, the argument <code>ci</code> represents the <a class="el" href="classKMCThinFilm_1_1CellInds.html">indices of a lattice cell</a>. The operator executes an <em>over-lattice</em> event, so <code>ci.i</code> and <code>ci.j</code> are already random values. This takes care of the part of Meakin's algorithm where a random pair of in-plane indices is chosen. The variable <code>kDepAtom</code> is used to store the current active zone height for the in-plane indices  \((\mathtt{ci.i},
\mathtt{ci.j})\). Since the active zone heights are stored only within the <em>first</em> plane of the lattice, <code>ciInPlane.k</code> is zero.</p>
<p>Before placing a particle in the lattice cell at <code>ciTo</code>, or  \((\mathtt{ci.i}, \mathtt{ci.j},
\mathtt{kDepAtom})\), it must be ensured that this cell is actually available in the computational lattice. This is what the call to <a class="el" href="classKMCThinFilm_1_1Lattice.html#aa36bda22ed2b0bc8d8737d3d63009765">KMCThinFilm::Lattice::addPlanes()</a> is for. The argument to this member function, if positive, is the number of lattice planes to add. Now <code>ci.k</code> is initially one less than the maximum number of lattice planes, that is, the maximum possible value of the third lattice coordinate, <em>k</em>. Accordingly, if \(\mathtt{ciTo.k} - \mathtt{ci.k}\) is positive, then it is the number of planes that would need to be added to ensure that <code>ciTo</code> is a valid set of indices. If it is zero or negative, then no planes need to be added, and then the call to <a class="el" href="classKMCThinFilm_1_1Lattice.html#aa36bda22ed2b0bc8d8737d3d63009765">KMCThinFilm::Lattice::addPlanes()</a> will simply do nothing. Once the call has been made, <a class="el" href="classKMCThinFilm_1_1Lattice.html#a81beda29c4c8722cb047f7f2ce0a09ce">KMCThinFilm::Lattice::setInt()</a> can be safely called.</p>
<p>The remainder of the implementation of the operator performing deposition, from the <code>for</code> loop onward, simply updates the values of \(h_a(i,j)\). The main feature of interest in this remaining part is the <a class="el" href="namespaceKMCThinFilm.html#a57489af951d041dc66872aea47fa3da2">&ldquo;<code>+</code>&rdquo; operator</a> applied to <code>ciInPlane</code> and <code>*offsetItr</code>. The meaning of this operator is such that the statement</p>
<div class="fragment"><div class="line">CellInds neighInPlane = ciInPlane + *offsetItr;</div>
</div><!-- fragment --><p>is equivalent to</p>
<div class="fragment"><div class="line">CellInds neighInPlane(ciInPlane.i + offsetItr-&gt;i,</div>
<div class="line">                      ciInPlane.j + offsetItr-&gt;j,</div>
<div class="line">                      ciInPlane.k + offsetItr-&gt;k);</div>
</div><!-- fragment --><p>This operator is not commutative; the offset must be its second operand.</p>
<p>Now normally, when <a class="el" href="classKMCThinFilm_1_1Lattice.html#aa36bda22ed2b0bc8d8737d3d63009765">KMCThinFilm::Lattice::addPlanes()</a> is called, the cells that it creates have the quantities associated with them (e.g. those labeled as <code>BDIntVal::IS_OCCUPIED</code>, <code>BDIntVal::ACTIVE_ZONE_HEIGHT</code>, and <code>BDFloatVal::COLOR</code>) all set to zero. However, this can be changed, and has been changed for this example. In the initialization of the simulation done via these lines in <code>testBallisticDep.cpp</code>,</p>
<div class="fragment"><div class="line">  <a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">RandNumGenSharedPtr</a> rng(<span class="keyword">new</span> <a class="code hl_class" href="classKMCThinFilm_1_1RandNumGenMT19937.html">RandNumGenMT19937</a>(seed));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structKMCThinFilm_1_1LatticeParams.html">LatticeParams</a> latParams;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a7a9d46d27758a276fd20d9c18156371a">numIntsPerCell</a> = BDIntVal::SIZE;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a55263f7f4ef826b814ffeaae27ddf687">numFloatsPerCell</a> = BDFloatVal::SIZE;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3a3cc62a6fb5fdda00ed2c63e1ff1020">globalPlanarDims</a>[0] = latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3a3cc62a6fb5fdda00ed2c63e1ff1020">globalPlanarDims</a>[1] = domainSize;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#afc58fe3eed9df51a18d9a3fe2ed3b8d1">setEmptyCellVals</a> = SetEmptyCellWithRandColor(rng);</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a1b5bd22cee6f39342f07f59fb31866c9">numPlanesToReserve</a> = 100;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1Simulation.html">Simulation</a> sim(latParams);</div>
</div><!-- fragment --><p>a special function object, an instance of <code>SetEmptyCellWithRandColor</code>, is used to initialize an empty cell. This function object is defined and implemented in the function files <code>InitLattice.hpp</code> and <code>InitLattice.cpp</code>, respectively, which are shown below:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef INIT_LATTICE_HPP</span></div>
<div class="line"><span class="preprocessor">#define INIT_LATTICE_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;KMCThinFilm/Lattice.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;KMCThinFilm/RandNumGen.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SetEmptyCellWithRandColor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  SetEmptyCellWithRandColor(<a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">KMCThinFilm::RandNumGenSharedPtr</a> rng)</div>
<div class="line">    : rng_(rng)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a> &amp; ci,</div>
<div class="line">                  <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> &amp; lattice,</div>
<div class="line">                  std::vector&lt;int&gt; &amp; emptyIntVals,</div>
<div class="line">                  std::vector&lt;double&gt; &amp; emptyFloatVals);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">KMCThinFilm::RandNumGenSharedPtr</a> rng_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* INIT_LATTICE_HPP */</span><span class="preprocessor"></span></div>
<div class="ttc" id="aclassKMCThinFilm_1_1CellInds_html"><div class="ttname"><a href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a></div><div class="ttdef"><b>Definition</b> CellInds.hpp:28</div></div>
<div class="ttc" id="aclassKMCThinFilm_1_1Lattice_html"><div class="ttname"><a href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a></div><div class="ttdef"><b>Definition</b> Lattice.hpp:217</div></div>
<div class="ttc" id="anamespaceKMCThinFilm_html_a7b5f253610505f71091c404d12d05aee"><div class="ttname"><a href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">KMCThinFilm::RandNumGenSharedPtr</a></div><div class="ttdeci">boost::shared_ptr&lt; RandNumGen &gt; RandNumGenSharedPtr</div><div class="ttdef"><b>Definition</b> RandNumGen.hpp:44</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;InitLattice.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EventsAndActions.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceKMCThinFilm.html">KMCThinFilm</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SetEmptyCellWithRandColor::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> &amp; ci,</div>
<div class="line">                                           <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">Lattice</a> &amp; lattice,</div>
<div class="line">                                           std::vector&lt;int&gt; &amp; emptyIntVals,</div>
<div class="line">                                           std::vector&lt;double&gt; &amp; emptyFloatVals) {</div>
<div class="line">  </div>
<div class="line">  emptyFloatVals[BDFloatVal::COLOR] = rng_-&gt;getNumInOpenIntervalFrom0To1();</div>
<div class="line">  </div>
<div class="line">}</div>
<div class="ttc" id="anamespaceKMCThinFilm_html"><div class="ttname"><a href="namespaceKMCThinFilm.html">KMCThinFilm</a></div><div class="ttdef"><b>Definition</b> CellCenteredGroupPropensities.hpp:13</div></div>
</div><!-- fragment --><p>Here, even an &ldquo;empty&rdquo; lattice cell has a color associated with it, which is randomly determined. Note that there is no need to resize the vectors used as output arguments of <code>SetEmptyCellWithRandColor::operator()</code>, since the sizes of these vectors have already been set to the number of integer and floating-point quantities, respectively, at each lattice cell.</p>
<p>Since multiple lattice planes will be added during the course of the simulation, <code>latParams.numPlanesToReserve</code> is set to roughly the number of planes that might be added. This reserves space in memory for those planes but does not add them to the lattice outright. Actually adding the planes is done by <a class="el" href="classKMCThinFilm_1_1Lattice.html#aa36bda22ed2b0bc8d8737d3d63009765">KMCThinFilm::Lattice::addPlanes()</a>. <code>latParams.numPlanesToReserve</code> is <em>not</em> a hard limit on the number of lattice planes that may be added; it merely affects performance.</p>
<dl class="section note"><dt>Note</dt><dd>While this example of a means of initializing an empty lattice is contrived, a not-so contrived example would be a case where the lattice is distorted and the current coordinates of a particle, which may be near rather than exactly at a lattice site, are stored at a lattice cell. In a new empty cell, it would make sense for these coordinates to be initialized not to zero, but rather to some function of the lattice indices \((i,j,k)\), e.g.  \(\mathbf{a}_i i + \mathbf{a}_j j + \mathbf{a}_k k +
\mathbf{b}\), where \(\mathbf{a}_i\), \(\mathbf{a}_j\), and \(\mathbf{a}_k\) are primitive lattice vectors and \(\mathbf{b}\) is a basis vector.</dd></dl>
<p>The enumeration associated with the offsets used in the function object classes involved in the color change in a lattice cell is as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="MakeEnum_8hpp.html#a18b06446141f866d52168964dbc824c7">KMC_MAKE_OFFSET_ENUM</a>(MIX_OFFSET,</div>
<div class="line">                     NORTH, SOUTH, WEST, EAST <span class="comment">/* First four neighbors are lateral */</span>, </div>
<div class="line">                     UP, DOWN);</div>
</div><!-- fragment --><p>The definition for the function object class defining the propensity for the color change in a lattice cell is</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ColorMixPropensity {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  ColorMixPropensity(<span class="keywordtype">double</span> mixPropPerNeighbor)</div>
<div class="line">    : mixPropPerNeighbor_(mixPropPerNeighbor)</div>
<div class="line">  {} </div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellNeighProbe &amp; cnp,</div>
<div class="line">                  std::vector&lt;double&gt; &amp; propensityVec) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">double</span> mixPropPerNeighbor_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>and its implementation is</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ColorMixPropensity::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellNeighProbe.html">KMCThinFilm::CellNeighProbe</a> &amp; cnp,</div>
<div class="line">                                    std::vector&lt;double&gt; &amp; propensityVec)<span class="keyword"> const </span>{</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(MIX_OFFSET::SELF), BDIntVal::IS_OCCUPIED)) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> numNeighs = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Visiting four lateral neighbors</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> whichOffset = 1; whichOffset &lt;= 4; ++whichOffset) {</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(whichOffset), BDIntVal::IS_OCCUPIED)) {</div>
<div class="line">        ++numNeighs;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classKMCThinFilm_1_1CellToProbe.html">CellToProbe</a> downCell = cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(MIX_OFFSET::DOWN);</div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#acff2debf7ca2157b8ea1d58475a9f25f">belowLatticeBottom</a>(downCell) || cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(downCell, BDIntVal::IS_OCCUPIED)) {</div>
<div class="line">      ++numNeighs;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classKMCThinFilm_1_1CellToProbe.html">CellToProbe</a> upCell = cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(MIX_OFFSET::UP);</div>
<div class="line">    <span class="keywordflow">if</span> ((!cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1c68a11a6d1af530abf21ed070ae452c">exceedsLatticeHeight</a>(upCell)) &amp;&amp; cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(upCell, BDIntVal::IS_OCCUPIED)) {</div>
<div class="line">      ++numNeighs;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    propensityVec[CellCenteredEvents::COLOR_MIXING] = mixPropPerNeighbor_*numNeighs;</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are a couple new things to note.</p>
<p>First, the contributions of the lateral nearest neighboring cells are determined by looping over the <em>numeric</em> labels for the offsets, 1 through 4, rather than the symbolic constants <code>MIX_OFFSET::NORTH</code>, <code>MIX_OFFSET::SOUTH</code>, <code>MIX_OFFSET::WEST</code>, and <code>MIX_OFFSET::EAST</code>. This is perfectly legal; the <em>N</em> enumeration constants listed in the arguments of <a class="el" href="MakeEnum_8hpp.html#a18b06446141f866d52168964dbc824c7">KMC_MAKE_OFFSET_ENUM</a> will correspond respectively to the numbers 1 through <em>N</em>. (Note that the number zero corresponds to the offset <code>MIX_OFFSET::SELF</code>.) There is a tradeoff here. Iterating over <em>numeric</em> labels for the offsets may be less self-documenting, but using the symbolic enumeration constants may involve more &ldquo;cut-and-paste&rdquo; code.</p>
<p>Second, when probing the non-lateral neighbors, the member functions <a class="el" href="classKMCThinFilm_1_1CellNeighProbe.html#acff2debf7ca2157b8ea1d58475a9f25f">KMCThinFilm::CellNeighProbe::belowLatticeBottom()</a> and <a class="el" href="classKMCThinFilm_1_1CellNeighProbe.html#a1c68a11a6d1af530abf21ed070ae452c">KMCThinFilm::CellNeighProbe::exceedsLatticeHeight()</a> are used to ensure that calls to <a class="el" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">KMCThinFilm::CellNeighProbe::getInt()</a> are only applied to <a class="el" href="classKMCThinFilm_1_1CellToProbe.html">KMCThinFilm::CellToProbe</a> objects with valid indices (due to the short-circuit evaluation of operators <code>||</code> and <code>&amp;&amp;</code>). In two-dimensional serial simulations, in-plane indices <em>i</em> and <em>j</em> are always valid, because they are wrapped due to periodic boundary conditions, and in two-dimensional parallel simulations, in-plane indices <em>i</em> and <em>j</em> should always be valid if the size of the ghost regions of the lattice has been properly set. In three-dimensional simulations, index <em>k</em> could easily be set to an invalid value, either a negative value&mdash;referring to a cell effectively below the computational lattice&mdash;or a value that is greater or equal to the number of lattice planes&mdash;referring to a cell effectively above the computational lattice. Note that cells below the lattice are treated differently than those above it. Here, if cell indices point to a cell that would be below the computational lattice, <code>numNeighs</code> is incremented because such a cell is understood as belonging to the substrate onto which a film is being deposited. If cell indices point to a cell that would be above the computational lattice, <code>numNeighs</code> is not incremented, since such a cell is understood as belonging to the empty space above the film.</p>
<p>The definition for the function object class that would execute color mixing is as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ColorMixExecute {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  ColorMixExecute(<a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">KMCThinFilm::RandNumGenSharedPtr</a> rng_,</div>
<div class="line">                  <span class="keyword">const</span> KMCThinFilm::CellNeighOffsets * mixCNO,</div>
<div class="line">                  <span class="keywordtype">int</span> * numMixes);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellInds &amp; ci,</div>
<div class="line">                  <span class="keyword">const</span> KMCThinFilm::SimulationState &amp; simState,</div>
<div class="line">                  KMCThinFilm::Lattice &amp; lattice);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">KMCThinFilm::RandNumGenSharedPtr</a> rng_;</div>
<div class="line">  <span class="keyword">const</span> KMCThinFilm::CellNeighOffsets * mixCNO_;</div>
<div class="line">  <span class="keywordtype">int</span> * numMixes_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Private member <code>mixCNO_</code> is simply a pointer to the same set of offsets used to calculate the propensity for mixing, as seen in the part of the driver code, <code>testBallisticDep.cpp</code>, where cell-centered event types are added to the simulation:</p>
<div class="fragment"><div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellNeighOffsets.html">CellNeighOffsets</a> mixCNO(MIX_OFFSET::SIZE);</div>
<div class="line">  mixCNO.addOffset(MIX_OFFSET::NORTH, <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(+1, 0, 0));</div>
<div class="line">  mixCNO.addOffset(MIX_OFFSET::SOUTH, <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(-1, 0, 0));</div>
<div class="line">  mixCNO.addOffset(MIX_OFFSET::WEST,  <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>( 0,-1, 0));</div>
<div class="line">  mixCNO.addOffset(MIX_OFFSET::EAST,  <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>( 0,+1, 0));</div>
<div class="line">  mixCNO.addOffset(MIX_OFFSET::UP,    <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>( 0, 0,+1));</div>
<div class="line">  mixCNO.addOffset(MIX_OFFSET::DOWN,  <a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>( 0, 0,-1));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> numMixes;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1EventExecutorGroup.html">EventExecutorGroup</a> mixExec(CellCenteredEvents::SIZE);</div>
<div class="line"> </div>
<div class="line">  mixExec.addEventExecutor(CellCenteredEvents::COLOR_MIXING,</div>
<div class="line">                           ColorMixExecute(rng, &amp;mixCNO, &amp;numMixes));</div>
<div class="line"> </div>
<div class="line">  sim.reserveCellCenteredEventGroups(1, CellCenteredEvents::SIZE);</div>
<div class="line">  sim.addCellCenteredEventGroup(1, mixCNO,</div>
<div class="line">                                ColorMixPropensity(10*F),</div>
<div class="line">                                mixExec);</div>
</div><!-- fragment --><p>Private member <code>numMixes_</code> will be used to keep track of how many times a color mixing event is executed. One can see from the above code and from the code of the constructor of <code>ColorMixExecute</code> below,</p>
<div class="fragment"><div class="line">ColorMixExecute::ColorMixExecute(<a class="code hl_typedef" href="namespaceKMCThinFilm.html#a7b5f253610505f71091c404d12d05aee">RandNumGenSharedPtr</a> rng,</div>
<div class="line">                                 <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellNeighOffsets.html">CellNeighOffsets</a> * mixCNO,</div>
<div class="line">                                 <span class="keywordtype">int</span> * numMixes)</div>
<div class="line">  : rng_(rng), </div>
<div class="line">    mixCNO_(mixCNO),</div>
<div class="line">    numMixes_(numMixes) {</div>
<div class="line"> </div>
<div class="line">  *numMixes_ = 0;</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>that this private member points to the integer variable <code>numMixes</code> in the driver code. After the simulation has finished running, the value of <code>numMixes</code> will be printed.</p>
<p>The implementation of the operator in the <code>ColorMixExecute</code> class that executes color mixing is shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ColorMixExecute::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a> &amp; ci,</div>
<div class="line">                                 <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">KMCThinFilm::SimulationState</a> &amp; simState,</div>
<div class="line">                                 <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> &amp; lattice) {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> color = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a825ef41025b740e190d60d097f9d9ae5">getFloat</a>(ci, BDFloatVal::COLOR);</div>
<div class="line">  <span class="keywordtype">int</span> numColors = 1;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Visiting four lateral neighbors</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> whichOffset = 1; whichOffset &lt;= 4; ++whichOffset) {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ciNeigh = ci + mixCNO_-&gt;getOffset(whichOffset);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ciNeigh, BDIntVal::IS_OCCUPIED)) {</div>
<div class="line">      color += lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a825ef41025b740e190d60d097f9d9ae5">getFloat</a>(ciNeigh, BDFloatVal::COLOR);</div>
<div class="line">      ++numColors;      </div>
<div class="line">    }</div>
<div class="line">      </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ciDown = ci +  mixCNO_-&gt;getOffset(MIX_OFFSET::DOWN);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> belowLatticeBottom = (ciDown.k &lt; 0);</div>
<div class="line">  <span class="keywordtype">bool</span> ciDownIsOccupied = (belowLatticeBottom || lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ciDown, BDIntVal::IS_OCCUPIED));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (ciDownIsOccupied) {</div>
<div class="line">    color += (belowLatticeBottom ?</div>
<div class="line">              (rng_-&gt;getNumInOpenIntervalFrom0To1()) :</div>
<div class="line">              lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a825ef41025b740e190d60d097f9d9ae5">getFloat</a>(ciDown, BDFloatVal::COLOR));</div>
<div class="line">    ++numColors;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ciUp = ci +  mixCNO_-&gt;getOffset(MIX_OFFSET::UP);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> ((ciUp.k &lt; lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a79fcfbbdb100a422553f1648019aab1a">currHeight</a>()) &amp;&amp; lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt</a>(ciUp, BDIntVal::IS_OCCUPIED)) {</div>
<div class="line"> </div>
<div class="line">    color += lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a825ef41025b740e190d60d097f9d9ae5">getFloat</a>(ciUp, BDFloatVal::COLOR);</div>
<div class="line">    ++numColors;</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aefe9601bf62fdb46d451d61fa017e691">setFloat</a>(ci, BDFloatVal::COLOR, color/numColors);</div>
<div class="line"> </div>
<div class="line">  ++(*numMixes_);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Whereas in the function object to calculate propensity, there were special member functions to check whether index <em>k</em> of some set of cell indices was less than zero or greater than or equal to the lattice height, here such checks are performed &ldquo;manually,&rdquo; so to speak. Also, again cells below the computational lattice are here treated differently than those above it. Cells below the lattice are again assumed to belong to the substrate, and for this contrived example, each particle in the substrate is assumed to have a random color. Cells above the computational lattice are again assumed to belong to the empty space above the deposited thin film, and thus do not contribute to the new value of the color of the cell.</p>
<p>The periodic action used to dump the state of the lattice to a file uses a file format called &ldquo;<a href="http://www.visitusers.org/index.php?title=Reading_point_data">Point3D</a>,&rdquo;, which can viewed with the software VisIt &lt;<a href="http://visit.llnl.gov">http://visit.llnl.gov</a>&gt;. It is used to display arrangements of particles colored according to some quantity, which in this case is the so-callled color of each lattice cell. The last snapshot, when viewed in VisIt, should look something like this:</p>
<div class="image">
<img src="testBallisticDep1_visit3D.png" alt=""/>
</div>
 <p>A slice of this snapshot in VisIt, showing particles with cell index <em>j</em> = 50, should look something like this:</p>
<div class="image">
<img src="testBallisticDep1_visit_slice_y50.png" alt=""/>
</div>
 <h2><a class="anchor" id="example_baldep_impl2"></a>
Second implementation</h2>
<p>One may have noticed a problem with the implementation of ballistic deposition described above. While only the values of the quantity labeled <code>BDIntVal::ACTIVE_ZONE_HEIGHT</code> in the first lattice plane are used, this quantity is defined for all cells of the lattice, which is somewhat wasteful. In this alternate implementation, then, the values of the auxiliary array \(h_a(i,j)\) will be stored not within the first plane of the lattice, but rather in a separate auxiliary array. Also, semi-manual tracking will be used for this example. The code for this new implementation is in <code>doc/example-code/testBallisticDep2</code> of the installation directory of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library.</p>
<p>We begin by defining <code>IntArray2D</code> in <code>EventsAndActions.hpp</code>, a type for a two-dimensional integer array, using the multi-array implementation from Boost &lt;<a href="http://www.boost.org">http://www.boost.org</a>&gt;, and a shared pointer for that type, also using a &ldquo;smart&rdquo; pointer implementation from the Boost library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/multi_array.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/shared_ptr.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::multi_array&lt;int, 2&gt; IntArray2D;</div>
<div class="line"><span class="keyword">typedef</span> boost::shared_ptr&lt;IntArray2D&gt; IntArray2DSharedPtr;</div>
</div><!-- fragment --><p>In the definition of the function object class performing ballistic deposition,</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DepositionExecute {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  DepositionExecute(<span class="keyword">const</span> KMCThinFilm::LatticePlanarBBox &amp; planarBBox);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellInds &amp; ci,</div>
<div class="line">                  <span class="keyword">const</span> KMCThinFilm::SimulationState &amp; simState,</div>
<div class="line">                  <span class="keyword">const</span> KMCThinFilm::Lattice &amp; lattice,</div>
<div class="line">                  std::vector&lt;KMCThinFilm::CellsToChange&gt; &amp; ctcVec);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  IntArray2DSharedPtr activeZoneHeights_;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;KMCThinFilm::CellIndsOffset&gt; neighOffsets_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>we have a shared pointer to an <code>IntArray2D</code> object, <code>activeZoneHeights_</code>. The constructor takes a <a class="el" href="structKMCThinFilm_1_1LatticePlanarBBox.html">KMCThinFilm::LatticePlanarBBox</a> parameter object, which is used to size the array to which <code>activeZoneHeights_</code> points:</p>
<div class="fragment"><div class="line">DepositionExecute::DepositionExecute(<span class="keyword">const</span> <a class="code hl_struct" href="structKMCThinFilm_1_1LatticePlanarBBox.html">LatticePlanarBBox</a> &amp; planarBBox)</div>
<div class="line">: activeZoneHeights_(new IntArray2D) {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The resize() member function will initialize the elements of this</span></div>
<div class="line">  <span class="comment">// array to zero.</span></div>
<div class="line">  activeZoneHeights_-&gt;resize(boost::extents[planarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a8bc6629f20496b2845d66f924a04f35a">imaxP1</a> - planarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a9de43623938e1ceb68c26feafd4cd009">imin</a>]</div>
<div class="line">                             [planarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#abedcda2c34e2bdfe0404e22838ed33dd">jmaxP1</a> - planarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#aa227140b560487687496bdbaef79d85e">jmin</a>]);</div>
<div class="line">  </div>
<div class="line">  neighOffsets_.reserve(4);</div>
<div class="line">  neighOffsets_.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>( 0,-1));</div>
<div class="line">  neighOffsets_.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>( 0,+1));</div>
<div class="line">  neighOffsets_.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(-1, 0));</div>
<div class="line">  neighOffsets_.push_back(<a class="code hl_class" href="classKMCThinFilm_1_1CellIndsOffset.html">CellIndsOffset</a>(+1, 0));</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>In the driver code <code>testBallisticDep.cpp</code>, the <a class="el" href="structKMCThinFilm_1_1LatticePlanarBBox.html">KMCThinFilm::LatticePlanarBBox</a> parameter object passed to this constructor contains the lateral bounds of the global lattice.</p>
<p>Finally, the implementation of ballistic deposition is as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DepositionExecute::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">KMCThinFilm::CellInds</a> &amp; ci,</div>
<div class="line">                                   <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1SimulationState.html">KMCThinFilm::SimulationState</a> &amp; simState,</div>
<div class="line">                                   <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> &amp; lattice,</div>
<div class="line">                                   std::vector&lt;KMCThinFilm::CellsToChange&gt; &amp; ctcVec) {</div>
<div class="line">  </div>
<div class="line">  <span class="comment">/* Ballistic deposition algorithm for cubic lattices from Meakin and</span></div>
<div class="line"><span class="comment">     Krug, Physical Review A, vol. 46, num. 6, pp. 3390-3399 (1992).*/</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> kDepAtom = (*activeZoneHeights_)[ci.i][ci.j];</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ciTo(ci.i, ci.j, kDepAtom);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellsToChange.html">CellsToChange</a> &amp; ctc = ctcVec[0];</div>
<div class="line"> </div>
<div class="line">  ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#a8a56c1106701d5bc3409cd30343fee2c">setCenter</a>(ciTo);</div>
<div class="line">  </div>
<div class="line">  ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#a6753306ace3d33af03814bfb048498b5">addLatticePlanes</a>(ciTo.k - ci.k);</div>
<div class="line">  ctc.<a class="code hl_function" href="classKMCThinFilm_1_1CellsToChange.html#a62079b840cc200e37e2907ba2e394f78">setInt</a>(0, BDIntVal::IS_OCCUPIED, 1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::vector&lt;CellIndsOffset&gt;::const_iterator offsetItr = neighOffsets_.begin(),</div>
<div class="line">         offsetItrEnd = neighOffsets_.end(); offsetItr != offsetItrEnd; ++offsetItr) {</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> neigh = ciTo + *offsetItr;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> i = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#ad86c9013774b072638db5527ced49cf8">wrapI</a>(neigh);</div>
<div class="line">    <span class="keywordtype">int</span> j = lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a837c173e46cb56875b02dbdb27da71c9">wrapJ</a>(neigh);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> ((*activeZoneHeights_)[i][j] &lt; kDepAtom) {</div>
<div class="line">      (*activeZoneHeights_)[i][j] = kDepAtom;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  ++((*activeZoneHeights_)[ci.i][ci.j]);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that since <code>activeZoneHeights_</code> is an external array, we use <a class="el" href="classKMCThinFilm_1_1Lattice.html#ad86c9013774b072638db5527ced49cf8">KMCThinFilm::Lattice::wrapI()</a> and <a class="el" href="classKMCThinFilm_1_1Lattice.html#a837c173e46cb56875b02dbdb27da71c9">KMCThinFilm::Lattice::wrapJ()</a> to ensure that the array indices used with <code>activeZoneHeights_</code> are correctly wrapped to account for periodic boundary conditions. This was not necessary when \(h_a(i,j)\) was stored in the first plane of the lattice and <a class="el" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">KMCThinFilm::Lattice::getInt()</a> was used to access its contents, since <a class="el" href="classKMCThinFilm_1_1Lattice.html#aff659b471f414c579a51fe280b218ef1">getInt()</a> automatically accounts for any periodic boundary conditions. Also, since semi-manual tracking is used, <code>lattice</code> is a <em>constant</em> reference, so planes must be added to the lattice via the member function <a class="el" href="classKMCThinFilm_1_1CellsToChange.html#a6753306ace3d33af03814bfb048498b5">KMCThinFilm::CellsToChange::addLatticePlanes()</a>.</p>
<p>One may ask why <code>activeZoneHeights_</code> is a pointer to an array instead of just an array. The reason for this is that when the <code>DepositionExecute</code> object is passed to <a class="el" href="classKMCThinFilm_1_1Simulation.html#affa3dff53afd248546457944b98376d9">KMCThinFilm::Simulation::addOverLatticeEvent()</a>, it is passed by value. This would mean that there would be two copies of the <code>activeZoneHeights_</code> array, one created when the <code>DepositionExecute</code> object is constructed, and another when a copy of this object is made to pass it by value. By using a pointer, only a pointer to the array is copied. A &ldquo;smart&rdquo; shared pointer is used so that it will automatically be deleted when there are no more references to it.</p>
<p>One downside of this implementation is that it is more difficult to parallelize than the previous one. With <code>*activeZoneHeights_</code> as a separate array, the process of splitting up the array, taking care of updates of ghost entries, etc. has to be handled explicitly. The handling of MPI communication could be done via a periodic action executed at each step, though one would need to refactor the code so that a <code>DepositionExecute</code> object and the function object performing the periodic action could both access the array containing \(h_a(i,j)\).</p>
<p>The resulting simulated thin film produced by this implementation is similar to that produced in the previous simulation but not the same, even if the same seed to the random number generator has been used. This is because the previous implementation contains calls to <code>lattice.setInt(..., BDIntVal::ACTIVE_ZONE_HEIGHT,
...)</code> in the function object that executes a deposition event. This triggers the solvers in the simulation to examine the possible events in the neighborhood of where the value of the quantity labeled <code>BDIntVal::ACTIVE_ZONE_HEIGHT</code> has been changed, which, due to implementation details in the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library, ends up changing the order that possible events with the same propensity are stored, which in turn affects which event is randomly chosen at a time step.</p>
<h1><a class="anchor" id="example_pat_sub"></a>
Example: Implementations of a patterned substrate model</h1>
<p>This example is meant to show how the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library may be used to implement models that are unusual in the sense that they have features that would almost inevitably require custom code to implement. An example of such a model is that of a patterned substrate <a class="el" href="citelist.html#CITEREF_kur99">[5]</a>. Like the fractal model, they use solid-on-solid modeling of a cubic lattice, which again means that the arrangement of atoms in the actual true lattice can be stored in a two-dimensional computational lattice, such that \((i,j,0)\) in the computational lattice stores the height of the column of particles at \((i,j,0)\) in the true lattice. As before, if a diffusing particle in the true lattice moves to a nearest-neighboring site that is not just above another particle, then the diffusing particle will fall until it lands on top of another particle. Also, if the site to which a particle attempts to move is occupied, then the particle will climb to the top of the column of particles that contains that occupied site. Falling and climbing are illustrated below, where an empty circle indicates the old position of a particle and a dark filled circle indicates the new position of a particle:</p>
<div class="image">
<img src="FallingAndClimbingParticles.png" alt=""/>
</div>
 <p>In one of the models of Kuronen et al., the propensity for the hopping of a particle at a lattice cell is   </p><p class="formulaDsp">
\[p = k\exp\left(-\frac{E}{k_B T}\right)
\]
</p>
<p> where \(k_B\) is the Boltzmann constant, <em>T</em> is temperature, \(k = kT/h\) with <em>h</em> being Planck's constant, and   </p><p class="formulaDsp">
\[E = E_s(i,j) + n E_n
\]
</p>
<p> Here, <em>n</em> is the number of occupied lateral neighbors of the cell, \(E_n\) (= 0.18 eV) is a measure of the bond strength between a particle and a lateral nearest neighboring particle, and \(E_s\) is a position-dependent diffusion barrier dependent on the patterning of the substrate, which varies with <em>i</em> and <em>j</em> as illustrated below, with brighter colors indicating higher values.</p>
<div class="image">
<img src="tiled16x16Domain_annotated.png" alt=""/>
</div>
 <p>The above pattern consists of a 16 &times; 16 array of square domains, and each domain is an array of 22 &times; 22 elements. This implies that the lattice has lateral dimensions (16&sdot;22) &times; (16&sdot;22). At the edge of a domain, \(E_s\) is at its minimum value, 0.65 eV, and at the center of a domain, it is at its maximum, 0.85 eV. \(E_s\) varies linearly between its minimum and maximum values.</p>
<p>The results of this patterned substrate model should be an arrangement of islands centered about the parts of the substrate where \(E_s\) is maximum.</p>
<h2><a class="anchor" id="example_pat_sub_impl1"></a>
First implementation</h2>
<p>The code for this implementation is in <code>doc/example-code/testPatternedSurface1</code> of the installation directory of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library. In it, the value \(E_s(i,j)\) is stored at cell \((i,j,0)\) of the computational lattice. This requires using a special method to initialize the lattice. The values of \(E_s(i,j)\) are stored in a file (entitled <code>tiled16x16Domain.dat</code>) where the first line contains the lateral dimensions of the lattice and subsequent lines are of the form</p>
<pre class="fragment">i j E_s(i,j)
</pre><p>where the first two numbers in the line are the lateral lattice cell indices and the third number is the value of \(E_s\) for those indices.</p>
<p>We begin with the files <code>InitLattice.hpp</code> and <code>InitLattice.cpp</code>, which contain the definition and implementation of the function object than initializes the lattice. The contents of the first file are</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef INIT_LATTICE_HPP</span></div>
<div class="line"><span class="preprocessor">#define INIT_LATTICE_HPP</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;KMCThinFilm/Lattice.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;KMCThinFilm/ErrorHandling.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>InitLatticeFromFile {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  InitLatticeFromFile(<span class="keyword">const</span> std::string &amp; inpFName)</div>
<div class="line">    : inpFName_(inpFName)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">KMCThinFilm::Lattice</a> &amp; lattice) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::string inpFName_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* INIT_LATTICE_HPP */</span><span class="preprocessor"></span></div>
</div><!-- fragment --><p>The constructor of the <code>InitLatticeFromFile</code> class here takes as an argument the name of the input file containing the values of \(E_s\). The contents of <code>InitLattice.cpp</code> are as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;InitLattice.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EventsAndActions.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/array.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceKMCThinFilm.html">KMCThinFilm</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> InitLatticeFromFile::operator()(<a class="code hl_class" href="classKMCThinFilm_1_1Lattice.html">Lattice</a> &amp; lattice)<span class="keyword"> const </span>{</div>
<div class="line">  </div>
<div class="line">  std::ifstream inpFile(inpFName_.c_str());</div>
<div class="line"> </div>
<div class="line">  boost::array&lt;int,2&gt; globalPlanarDims;</div>
<div class="line"> </div>
<div class="line">  inpFile &gt;&gt; globalPlanarDims[0] &gt;&gt; globalPlanarDims[1];</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structKMCThinFilm_1_1LatticePlanarBBox.html">LatticePlanarBBox</a> globalPlanarBBox;</div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#ac160d406b29dc80fb72551ad3d74ac3a">getGlobalPlanarBBox</a>(globalPlanarBBox);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespaceKMCThinFilm.html#acb9484dffdfd1584121f8a7c8bb8d924">exitOnCondition</a>((globalPlanarDims[0] != (globalPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a8bc6629f20496b2845d66f924a04f35a">imaxP1</a> - globalPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a9de43623938e1ceb68c26feafd4cd009">imin</a>)) ||</div>
<div class="line">                  (globalPlanarDims[1] != (globalPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#abedcda2c34e2bdfe0404e22838ed33dd">jmaxP1</a> - globalPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#aa227140b560487687496bdbaef79d85e">jmin</a>)),</div>
<div class="line">                  <span class="stringliteral">&quot;Mismatch in lattice dimensions and dimensions of strain eng. den. array.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aa36bda22ed2b0bc8d8737d3d63009765">addPlanes</a>(1);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structKMCThinFilm_1_1LatticePlanarBBox.html">LatticePlanarBBox</a> localPlanarBBox;</div>
<div class="line">  lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#a1504ff860e046a8965b37dd437a74c52">getLocalPlanarBBox</a>(<span class="keyword">false</span>, localPlanarBBox);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> maxLineNumP1 = (globalPlanarDims[0])*(globalPlanarDims[1]);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> ci; ci.k = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> lineNum = 0; lineNum &lt; maxLineNumP1; ++lineNum) {</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> i, j;</div>
<div class="line">    <span class="keywordtype">double</span> E_s;</div>
<div class="line"> </div>
<div class="line">    inpFile &gt;&gt; i &gt;&gt; j &gt;&gt; E_s;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> ((i &gt;= localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a9de43623938e1ceb68c26feafd4cd009">imin</a>) &amp;&amp; (i &lt; localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#a8bc6629f20496b2845d66f924a04f35a">imaxP1</a>) &amp;&amp; </div>
<div class="line">        (j &gt;= localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#aa227140b560487687496bdbaef79d85e">jmin</a>) &amp;&amp; (j &lt; localPlanarBBox.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticePlanarBBox.html#abedcda2c34e2bdfe0404e22838ed33dd">jmaxP1</a>)) {</div>
<div class="line"> </div>
<div class="line">      ci.i = i;</div>
<div class="line">      ci.j = j;</div>
<div class="line">        </div>
<div class="line">      lattice.<a class="code hl_function" href="classKMCThinFilm_1_1Lattice.html#aefe9601bf62fdb46d451d61fa017e691">setFloat</a>(ci, PSFloatVal::E_s, E_s);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line">    </div>
<div class="line">  inpFile.close();</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclassKMCThinFilm_1_1Lattice_html_a1504ff860e046a8965b37dd437a74c52"><div class="ttname"><a href="classKMCThinFilm_1_1Lattice.html#a1504ff860e046a8965b37dd437a74c52">KMCThinFilm::Lattice::getLocalPlanarBBox</a></div><div class="ttdeci">void getLocalPlanarBBox(bool wGhost, LatticePlanarBBox &amp;bbox) const</div></div>
<div class="ttc" id="aclassKMCThinFilm_1_1Lattice_html_aa36bda22ed2b0bc8d8737d3d63009765"><div class="ttname"><a href="classKMCThinFilm_1_1Lattice.html#aa36bda22ed2b0bc8d8737d3d63009765">KMCThinFilm::Lattice::addPlanes</a></div><div class="ttdeci">void addPlanes(int numPlanesToAdd)</div></div>
<div class="ttc" id="aclassKMCThinFilm_1_1Lattice_html_ac160d406b29dc80fb72551ad3d74ac3a"><div class="ttname"><a href="classKMCThinFilm_1_1Lattice.html#ac160d406b29dc80fb72551ad3d74ac3a">KMCThinFilm::Lattice::getGlobalPlanarBBox</a></div><div class="ttdeci">void getGlobalPlanarBBox(LatticePlanarBBox &amp;bbox) const</div></div>
<div class="ttc" id="aclassKMCThinFilm_1_1Lattice_html_aefe9601bf62fdb46d451d61fa017e691"><div class="ttname"><a href="classKMCThinFilm_1_1Lattice.html#aefe9601bf62fdb46d451d61fa017e691">KMCThinFilm::Lattice::setFloat</a></div><div class="ttdeci">void setFloat(const CellInds &amp;ci, int whichInt, double val)</div></div>
<div class="ttc" id="anamespaceKMCThinFilm_html_acb9484dffdfd1584121f8a7c8bb8d924"><div class="ttname"><a href="namespaceKMCThinFilm.html#acb9484dffdfd1584121f8a7c8bb8d924">KMCThinFilm::exitOnCondition</a></div><div class="ttdeci">void exitOnCondition(bool condition, const std::string &amp;msg)</div></div>
<div class="ttc" id="astructKMCThinFilm_1_1LatticePlanarBBox_html"><div class="ttname"><a href="structKMCThinFilm_1_1LatticePlanarBBox.html">KMCThinFilm::LatticePlanarBBox</a></div><div class="ttdef"><b>Definition</b> Lattice.hpp:51</div></div>
<div class="ttc" id="astructKMCThinFilm_1_1LatticePlanarBBox_html_a8bc6629f20496b2845d66f924a04f35a"><div class="ttname"><a href="structKMCThinFilm_1_1LatticePlanarBBox.html#a8bc6629f20496b2845d66f924a04f35a">KMCThinFilm::LatticePlanarBBox::imaxP1</a></div><div class="ttdeci">int imaxP1</div><div class="ttdef"><b>Definition</b> Lattice.hpp:53</div></div>
<div class="ttc" id="astructKMCThinFilm_1_1LatticePlanarBBox_html_a9de43623938e1ceb68c26feafd4cd009"><div class="ttname"><a href="structKMCThinFilm_1_1LatticePlanarBBox.html#a9de43623938e1ceb68c26feafd4cd009">KMCThinFilm::LatticePlanarBBox::imin</a></div><div class="ttdeci">int imin</div><div class="ttdef"><b>Definition</b> Lattice.hpp:52</div></div>
<div class="ttc" id="astructKMCThinFilm_1_1LatticePlanarBBox_html_aa227140b560487687496bdbaef79d85e"><div class="ttname"><a href="structKMCThinFilm_1_1LatticePlanarBBox.html#aa227140b560487687496bdbaef79d85e">KMCThinFilm::LatticePlanarBBox::jmin</a></div><div class="ttdeci">int jmin</div><div class="ttdef"><b>Definition</b> Lattice.hpp:54</div></div>
<div class="ttc" id="astructKMCThinFilm_1_1LatticePlanarBBox_html_abedcda2c34e2bdfe0404e22838ed33dd"><div class="ttname"><a href="structKMCThinFilm_1_1LatticePlanarBBox.html#abedcda2c34e2bdfe0404e22838ed33dd">KMCThinFilm::LatticePlanarBBox::jmaxP1</a></div><div class="ttdeci">int jmaxP1</div><div class="ttdef"><b>Definition</b> Lattice.hpp:55</div></div>
</div><!-- fragment --><p>This operator reads in the file containing the values of \(E_s(i,j)\), line by line, and stores these values in the floating-point array element labeled <code>PSFloatVal::E_s</code> in lattice cell \((i,j,0)\). The (global) lateral bounds of the lattice have already been initialized before this operator has even been invoked, so here there is a check to ensure that the lateral bounds of the lattice indicated in the first line of the file match the actual lateral bounds of the lattice. After this check, the actual initialization begins. First, a lattice plane is added with the <a class="el" href="classKMCThinFilm_1_1Lattice.html#aa36bda22ed2b0bc8d8737d3d63009765">KMCThinFilm::Lattice::addPlanes()</a> member function. Shortly afterward comes the reading in of the rest of the file containing the values of \(E_s(i,j)\). There is some allowance for parallel implementation. The local bounds of indices <em>i</em> and <em>j</em> are determined using <a class="el" href="classKMCThinFilm_1_1Lattice.html#a1504ff860e046a8965b37dd437a74c52">KMCThinFilm::Lattice::getLocalPlanarBBox</a>. While each MPI process would still read in the whole file, which is not that efficient, the process would also only store the values of \(E_s(i,j)\) for the lattice cell indices <em>i</em> and <em>j</em> whose values are within the previously determined local bounds.</p>
<p>In the driver file <code>testPatternedSurface.cpp</code>, the simulation is initialized as follows:</p>
<div class="fragment"><div class="line">  <a class="code hl_struct" href="structKMCThinFilm_1_1LatticeParams.html">LatticeParams</a> latParams;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a7a9d46d27758a276fd20d9c18156371a">numIntsPerCell</a> = PSIntVal::SIZE;</div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a55263f7f4ef826b814ffeaae27ddf687">numFloatsPerCell</a> = PSFloatVal::SIZE;</div>
<div class="line"> </div>
<div class="line">  std::ifstream patternFile(patternFName.c_str());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (patternFile) {</div>
<div class="line">    patternFile &gt;&gt; latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3a3cc62a6fb5fdda00ed2c63e1ff1020">globalPlanarDims</a>[0] &gt;&gt; latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3a3cc62a6fb5fdda00ed2c63e1ff1020">globalPlanarDims</a>[1];</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="namespaceKMCThinFilm.html#a77bd0cec2abe3a269140d80cfea34ed8">exitWithMsg</a>(<span class="stringliteral">&quot;Cannot access &quot;</span> + patternFName + </div>
<div class="line">                <span class="stringliteral">&quot;. Check if your are executing this program from the correct directory.&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  patternFile.close();</div>
<div class="line"> </div>
<div class="line">  latParams.<a class="code hl_variable" href="structKMCThinFilm_1_1LatticeParams.html#a3591118c88951f3a6c7de54117979c36">latInit</a> = InitLatticeFromFile(patternFName);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1Simulation.html">Simulation</a> sim(latParams);</div>
</div><!-- fragment --><p>Here, <code>patternFName</code> is the name of the file containing the values of \(E_s(i,j)\). The first line of this file is read in to determine the lateral dimensions of the lattice, and then the file is closed. Afterwards, the <em>latInit</em> member of the <a class="el" href="structKMCThinFilm_1_1LatticeParams.html">KMCThinFilm::LatticeParams</a> parameter object is set to an instance of the <code>InitLatticeFromFile</code> class, which is of course initialized to read from the file with the name <code>patternFName</code>. (This also means that this implementation is a bit inelegant, since part of the file <code>patternFName</code> will be read twice.)</p>
<p>This takes care of the initialization of the lattice.</p>
<p>Deposition here is done by the same means as in the example of the fractal solid-on-solid model using auto-tracking, while the execution of a hopping event is done by the same means as in the example of the fractal solid-on-solid model using semi-manual tracking. It is mainly the determination of a hopping event's propensity that is different. The definition of the function object class for determining propensity of hopping is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>HoppingPropensity {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  HoppingPropensity(<span class="keywordtype">double</span> E_n, <span class="keywordtype">double</span> T) </div>
<div class="line">    : E_n_(E_n), kBT_(PhysConst::kB*T), k_(kBT_/PhysConst::h)</div>
<div class="line">  {}</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellNeighProbe &amp; cnp,</div>
<div class="line">                  std::vector&lt;double&gt; &amp; propensityVec) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">double</span> E_n_, kBT_, k_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The constants <code>PhysConst::kB</code> and <code>PhysConst::h</code> are merely the Boltzmann constant and Planck's constant, and they are defined in the file <code>PhysicalConstants.hpp</code> of this example code. The private variables <code>E_n_</code>, <code>kBT_</code>, and <code>k_</code> correspond to the aforementioned expressions \(E_n\), \(k_B T\), and <em>k</em>. The implementation of the function object class for determining hopping propensity is shown below:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> HoppingPropensity::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellNeighProbe.html">CellNeighProbe</a> &amp; cnp,</div>
<div class="line">                                   std::vector&lt;double&gt; &amp; propensityVec)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellToProbe.html">KMCThinFilm::CellToProbe</a> ctpSelf = cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::SELF);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> currHeight = cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(ctpSelf, PSIntVal::HEIGHT);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (currHeight &gt; 0) {</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> n = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::UP), PSIntVal::HEIGHT) &gt;= currHeight) {</div>
<div class="line">      ++n;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::DOWN), PSIntVal::HEIGHT) &gt;= currHeight) {</div>
<div class="line">      ++n;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::LEFT), PSIntVal::HEIGHT) &gt;= currHeight) {</div>
<div class="line">      ++n;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::RIGHT), PSIntVal::HEIGHT) &gt;= currHeight) {</div>
<div class="line">      ++n;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> E = cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1425c18df394e394b7c50e9f332371fc">getFloat</a>(ctpSelf, PSFloatVal::E_s) + n*E_n_;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> p = k_*std::exp(-E/kBT_);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; PSCellCenteredEvents::SIZE; ++i) {</div>
<div class="line">      propensityVec[i] = p;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, <code>currHeight</code> is the height of the column of particles at \((\mathtt{ci.i}, \mathtt{ci.j}, 0)\) in the true lattice. Let \((i_{\mathrm{off}}, j_{\mathrm{off}})\) be an offset of cell indices, which for <code>HopOffset::UP</code> is \((0,+1)\), for <code>HopOffset::DOWN</code> is \((0,-1)\), for <code>HopOffset::LEFT</code> is \((-1,0)\), and for <code>HopOffset::RIGHT</code> is \((+1,0)\). If a column of particles at  \((\mathtt{ci.i} + i_{\mathrm{off}}, \mathtt{ci.j} +
j_{\mathrm{off}}, 0)\) is greater than or equal to <code>currHeight</code>, that means that the site \((\mathtt{ci.i}, \mathtt{ci.j}, \mathtt{currHeight} - 1)\) in the true lattice has an occupied nearest neighbor at  \((\mathtt{ci.i} + i_{\mathrm{off}}, \mathtt{ci.j} +
j_{\mathrm{off}}, \mathtt{currHeight} - 1)\), and the variable <code>n</code> is incremented accordingly. The calculation of the propensity, then, follows straightforwardly from the aforementioned formulas for the patterned substrate <a class="el" href="citelist.html#CITEREF_kur99">[5]</a>.</p>
<p>An overhead view of the surface of the islands on the patterned substrate at various simulation times <em>t</em>, from 2.27 units to its maximum value of 50.0 units, is shown below.</p>
<div class="image">
<img src="testPatSubSnapshots.png" alt=""/>
</div>
 <h2><a class="anchor" id="example_pat_sub_impl2"></a>
Second implementation</h2>
<p>The previous implementation of the patterned substrate model <a class="el" href="citelist.html#CITEREF_kur99">[5]</a> does not take advantage of the periodicity of \(E_s\). This new implementation will. Instead of storing values of \(E_s(i,j)\) in the computational lattice itself, they will be stored in a small array used by the function object used to calculate propensities. This means that no special means to initialize the lattice is required. The code for this implementation is in <code>doc/example-code/testPatternedSurface2</code> of the installation directory of the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library.</p>
<p>The file containing the values of \(E_s(i,j)\), <code>singleDomain.dat</code> only contains the values of \(E_s\) within a single domain of (22 &times; 22 array) elements. The first line of this file contains the dimensions of this domain, and the rest of the lines in this file have the following format,</p>
<pre class="fragment">i j E_s(i,j)
</pre><p>where the first two numbers in the line are the indices of the domain array and the third number is the value of \(E_s\) for those indices. In the driver code <code>testPatternedSurface.cpp</code>, this file is read into an array as follows,</p>
<div class="fragment"><div class="line">  DblArray2D E_s;</div>
<div class="line">  </div>
<div class="line">  std::ifstream patternFile(<span class="stringliteral">&quot;../singleDomain.dat&quot;</span>);</div>
<div class="line">  boost::array&lt;int,2&gt; E_s_extents;</div>
<div class="line"> </div>
<div class="line">  patternFile &gt;&gt; E_s_extents[0] &gt;&gt; E_s_extents[1];</div>
<div class="line">  E_s.resize(E_s_extents);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> E_s_i, E_s_j;</div>
<div class="line">  <span class="keywordtype">double</span> E_s_val;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (patternFile &gt;&gt; E_s_i &gt;&gt; E_s_j &gt;&gt; E_s_val) {</div>
<div class="line">    E_s[E_s_i][E_s_j] = E_s_val;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>where <code>DblArray2D</code> is defined in <code>EventsAndActions.hpp</code> as</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/multi_array.hpp&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> boost::multi_array&lt;double,2&gt; DblArray2D;</div>
</div><!-- fragment --><p>Again, we use the multi-array implementation from Boost &lt;<a href="http://www.boost.org">http://www.boost.org</a>&gt;. The function object for determining hopping propensity is defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>HoppingPropensity {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  HoppingPropensity(<span class="keyword">const</span> DblArray2D * E_s, <span class="keywordtype">double</span> E_n, <span class="keywordtype">double</span> T) </div>
<div class="line">    : E_s_(E_s), E_n_(E_n), kBT_(PhysConst::kB*T), k_(kBT_/PhysConst::h)</div>
<div class="line">  {}</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> KMCThinFilm::CellNeighProbe &amp; cnp,</div>
<div class="line">                  std::vector&lt;double&gt; &amp; propensityVec) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> DblArray2D * E_s_;</div>
<div class="line">  <span class="keywordtype">double</span> E_n_, kBT_, k_;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This function object is similar to the corresponding one in the previous implementation, except that now there is a new private variable, <code>E_s_</code>, which points to an array containing the values of \(E_s(i,j)\) in a domain (and, of course, a constructor with an argument used to set the value of this private variable). The reason for <code>E_s_</code> being a pointer is similar to the one for having <code>activeZoneHeights_</code> be a pointer in the second implementation of the ballistic deposition model. When an instance of the <code>HoppingPropensity</code> object is passed to <a class="el" href="classKMCThinFilm_1_1Simulation.html#ada268bce065b942617fd1331b083626d">KMCThinFilm::Simulation::addCellCenteredEventGroup()</a>, it is passed by value, and having <code>E_s_</code> be a pointer to an array rather than the array itself means that only a pointer to the array is copied rather than the whole array.</p>
<p>The function object for determining hopping propensity is implemented as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> HoppingPropensity::operator()(<span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellNeighProbe.html">CellNeighProbe</a> &amp; cnp,</div>
<div class="line">                                   std::vector&lt;double&gt; &amp; propensityVec)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classKMCThinFilm_1_1CellToProbe.html">KMCThinFilm::CellToProbe</a> ctpSelf = cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::SELF);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> currHeight = cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(ctpSelf, PSIntVal::HEIGHT);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (currHeight &gt; 0) {</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> n = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::UP), PSIntVal::HEIGHT) &gt;= currHeight) {</div>
<div class="line">      ++n;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::DOWN), PSIntVal::HEIGHT) &gt;= currHeight) {</div>
<div class="line">      ++n;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::LEFT), PSIntVal::HEIGHT) &gt;= currHeight) {</div>
<div class="line">      ++n;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a7be3ba45264054167a243f15a1954b92">getInt</a>(cnp.<a class="code hl_function" href="classKMCThinFilm_1_1CellNeighProbe.html#a1ba997186f6326b525dd66df4254d198">getCellToProbe</a>(HopOffset::RIGHT), PSIntVal::HEIGHT) &gt;= currHeight) {</div>
<div class="line">      ++n;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classKMCThinFilm_1_1CellInds.html">CellInds</a> &amp; ciSelf = ctpSelf.<a class="code hl_function" href="classKMCThinFilm_1_1CellToProbe.html#a9b2f2133ce27c287b7ece18d8df929ac">inds</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> coord_i_in_domain = ciSelf.i % (E_s_-&gt;shape()[0]);</div>
<div class="line">    <span class="keywordtype">int</span> coord_j_in_domain = ciSelf.j % (E_s_-&gt;shape()[1]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> E = (*E_s_)[coord_i_in_domain][coord_j_in_domain] + n*E_n_;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> p = k_*std::exp(-E/kBT_);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; PSCellCenteredEvents::SIZE; ++i) {</div>
<div class="line">      propensityVec[i] = p;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function object is also similar to the corresponding one in the previous implementation, except that</p>
<ol type="1">
<li>it actually accesses lattice cell indices, via the member function <a class="el" href="classKMCThinFilm_1_1CellToProbe.html#a9b2f2133ce27c287b7ece18d8df929ac">KMCThinFilm::CellToProbe::inds()</a>, and</li>
<li>it converts the in-plane cell indices, <code>ciSelf.i</code> and <code>ciSelf.j</code>, into indices <code>coord_i_in_domain</code> and <code>coord_j_in_domain</code> of the array to which <code>E_s_</code> points.</li>
</ol>
<p>The latter is more a matter for the particular kinetic Monte Carlo model being implemented, but the former is more generally useful functionality.</p>
<p>The rest of this implementation is the same as the previous one. Provided that the same parameters, lattice dimensions, domain dimensions, and seeding for the random number generator are used in both this implementation and the previous one, the two implementations should yield exactly the same results. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
