<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ARL KMCThinFilm: Concepts and algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ARL KMCThinFilm<span id="projectnumber">&#160;0.2.7</span>
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('concepts_and_algorithms.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Concepts and algorithms</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="kMC_sim_overview"></a>
Basics of kinetic Monte Carlo simulation as implemented in the ARL KMCThinFilm library</h1>
<p>In the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library, a simulation is an object that executes the <em>n</em>-fold way algorithm <a class="el" href="citelist.html#CITEREF_bor75">[2]</a>, where at a given time step in the simulation, the set of all possible events in a system and their associated rate constants or propensities (i.e. probabilities per unit time) is determined, and one of these events is then randomly chosen to be executed, with the choice weighted according the propensities of the possible events. Following a later kMC work <a class="el" href="citelist.html#CITEREF_fic91">[4]</a>, the simulation time at each step is advanced by \(-\ln{r}/p_{tot}\), where <em>r</em> is a random number uniformly chosen from the open interval (0,1), and \(p_{tot}\) is the sum of all the propensities of all possible events. To simplify the process of determining the set of possible events, each possible event is assumed to cause some sort of change to cells in a lattice. This lattice is itself an object that is owned by the simulation object, and it is initialized when the simulation object is initialized. Possible events are assumed to be of one of two kinds:</p>
<ul>
<li><em>Cell-centered</em>. This is a type of event that originates in the neighborhood of some lattice cell, and a propensity of an instance of such an event at a particular cell is affected by the states of cells in the neighborhood of that particular cell. Adsorption, diffusion, or chemical reactions are examples of such events. Since the propensities of related cell-centered events can often be calculated using the same or almost the same series of steps, types of cell-centered events may be collected into one or more groups. A group of cell-centered event types consists of the following components:<ul>
<li>An integer label identifying the group of event types.</li>
<li>A set of the relative locations of the cells in the aforementioned neighborhood, which are called &ldquo;<a class="el" href="classKMCThinFilm_1_1CellIndsOffset.html">offsets</a>.&rdquo;</li>
<li>A function or function object that calculates what amounts to an array (or more precisely, an <a href="http://www.cplusplus.com/reference/vector/">STL vector</a>) of propensities, one for each instance of a type of event in the group happening at a given cell. This function/function object is given very limited access to the lattice object owned by the simulation. In particular, it can only read the states of lattice cells within the neighborhood of cells defined by the offsets mentioned above.</li>
<li>A group of functions or function objects, one for each type of event in the group of cell-centered event types, that can execute an instance of that event type about a given cell. Each of these function/function objects can alter the lattice that is owned by the simulation object, and not just the cells of the lattice within a certain neighborhood of the cell about which an event is centered. In addition, it has read-only access to some aspects of the current <a class="el" href="classKMCThinFilm_1_1SimulationState.html">simulation state</a>, such as the elapsed simulation time. Optionally, for each function/function object in the group, there may be a set of offsets that indicate the relative locations of cells directly changed by the execution of the event, and this may be used to speed up the simulation.</li>
</ul>
</li>
<li><em>Over-lattice</em>. This is a type of event that, from a physical perspective, is assumed to have actually originated at some point well above the lattice, out of the range of influence of things that happen at the surface or interior of the lattice. Deposition would be the chief example of this type of event. An over-lattice event type consists of the following components:<ul>
<li>An integer label identifying the type of event.</li>
<li>A propensity per unit area, i.e., the propensity of the event divided by the number of cells in a lattice monolayer. A deposition flux given in terms of the number of monolayers per unit time is already a propensity per unit area.</li>
<li>A function or function object that can execute an instance of this event type originating from a randomly picked cell at the top of the lattice. This function/function object can alter the lattice that is owned by the simulation object, and if need be, it can alter cells that are far distant from the originating randomly picked cell. It also has read-only access to some aspects of the current <a class="el" href="classKMCThinFilm_1_1SimulationState.html">simulation state</a>, (e.g. elapsed simulation time).</li>
</ul>
</li>
</ul>
<p>After the simulation object is initialized, these event types are added to the object. Once these types are added, the simulation is then run for a certain amount of simulation time. A simulation can also be restarted from where it left off, and before restarting, event types can be added, modified, or removed from a simulation object. For example, one could add both deposition and diffusion event types to a simulation, run the simulation for \(t_{dep}\) units of time, then remove the deposition event type, change the objects that calculate the propensities of the diffusion event type to those for a higher temperature, and then restart the simulation from where it left off for \(t_{anneal}\) units of simulation time.</p>
<p>At the beginning of a simulation run, each cell of the lattice is scanned in order to determine the initial set of possible events and their propensities. When an event is executed at a time step, the locations of the lattice cells directly changed by this event, as well as certain cells within a neighborhood of these changed cells, are recorded. The list of recorded cell indices, then, is used to incrementally update the set of possible events and propensities, avoiding the computational cost of scanning each cell of the the lattice at each time step to refresh this set. This list is constructed from the offsets used to define cell-centered events. More precisely, it is constructed using a master list of offsets that is generated at the beginning of the simulation run, one that is the union of all the offsets of cell-centered events. If <em>auto-tracking</em> is used to track the locations of the directly affected cells, then when an event is executed, for each cell \((a_n,b_n,c_n)\) directly changed by the event, cell indices \((a_n,b_n,c_n)\),  \((a_n - i_1, b_n -
j_1, c_n - k_1)\), \((a_n - i_2, b_n - j_2, c_n - k_2)\), etc. will be added to the list of indices of cells affected by the event, where \((i_1,j_1,k_1)\), \((i_2,j_2,k_2)\), &hellip;, is the master list of offsets. When this list of indices is constructed in this way, there may be redundancies in the list. These redundancies won't lead to spurious results, but they will lead to redundant propensity calculations, since a propensity calculation is done for every item in the list. To avoid this, <em>semi-manual</em> tracking may be used. To use this mode of tracking for a cell-centered event, sets of offsets  \(\{O_1, O_2,
\dots\}\), indicating the relative locations of cells changed by an event, must be specified for the type of this cell-centered event. From this information and the master list of offsets, new lists of offsets are constructed, one for each set \(O_m\). For each offset \((a^m_n,b^m_n,c^m_n)\) in set \(O_m\), a list of offsets  \(l^m_n = (a^m_n,b^m_n,c^m_n), (a^m_n - i_1, b^m_n - j_1,
c^m_n - k_1), (a^m_n - i_2, b^m_n - j_2, c^m_n - k_2)\), etc. is generated, where \((i_1,j_1,k_1)\), \((i_2,j_2,k_2)\), &hellip;, again is the master list of offsets. The list \(L_m\) is then constructed as the union of all offsets in the lists \(l^m_1\), \(l^m_2\), &hellip;. When an event is executed, for each set \(O_m\), one of the cells affected by the event is designated as <em>center</em> \(m\). For each center \(m\), the indices of the rest of the cells changed by the event are formed adding the indices of this center to each of the offsets in \(O_m\). The list of recorded cell indices is then composed of the indices of these centers, and the indices formed from adding the indices of center \(m\) to each of the offsets in \(L_m\). If the centers are far enough apart or there is only one center, then the list of recorded cell indices should have no redundant values.</p>
<p>The process of choosing a random event may be done with one of two algorithms, which in the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library are called <em>solvers</em>. One algorithm <a class="el" href="citelist.html#CITEREF_blu95">[1]</a> stores the <em>N</em> possible events and partial sums of their propensities in a binary tree and scales as  \(O(\log_2
N)\). Another algorithm stores possible events in a map where the key is a propensity of a possible event, and the value associated with that key is an array of possible events associated with that propensity. This algorithm scales with the number of unique propensity values in the system, which in many cases is independent of the number of possible events <em>N</em>. This is similar to another algorithm <a class="el" href="citelist.html#CITEREF_sch02">[8]</a>, except that algorithm used a two-dimensional array rather than a map.</p>
<p>In addition to possible events, <em>periodic actions</em> can be executed during a simulation as well. There are two types of periodic actions: <em>time-periodic</em> actions, which occur after every <em>t</em> units of simulation time, and <em>step-periodic</em> actions, which occur after every <em>M</em> time steps. These may perform various functions, from I/O operations, e.g. to record to a file the state of the lattice at various points during a simulation, or to even change the lattice or quantities associated with it. Like possible events, periodic actions can be added, changed, or removed from a simulation object.</p>
<h1><a class="anchor" id="lattice_overview"></a>
Lattices in the ARL KMCThinFilm library</h1>
<p>A lattice in the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library is modeled as a stack of two-dimensional arrays of cells, with each cell labeled with a triplet of integer indices, as illustrated in the figure below.</p>
<div class="image">
<img src="LatticeModel.png" alt=""/>
</div>
 <p>Periodic boundary conditions always apply to the first two indices of a cell, but not the third. In a manner similar to that of the software SPPARKS &lt;<a href="http://spparks.sandia.gov">http://spparks.sandia.gov</a>&gt;, each cell also contains two one-dimensional arrays, one with integer values and one with double precision floating-point values. The size of these arrays is the same for all cells. The physical meaning of the contents of the arrays is left up to the client application that uses the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library; for a given application, they may be used to identify species of a basis of atoms within a cell, or the spatial coordinates of an atom in a cell in a possibly distorted lattice, or, for a simpler solid-on-solid application, the height of a column of atoms at \((i,j,0)\). The lattice need not be cubic. If the cells are treated as those of a Bravais lattice with primitive lattice vectors \(\mathbf{a}_i\), \(\mathbf{a}_j\), and \(\mathbf{a}_k\), then the physical location of cell \((i,j,k)\) may be said to be  \(\mathbf{a}_i i + \mathbf{a}_j j
+ \mathbf{a}_k k\). The sizes of the arrays in each cell of the lattice, as well as the maximum values of the first two indices of a cell, are fixed when the lattice is initialized, but additional planes may be added to the lattice at any time step of the simulation.</p>
<h1><a class="anchor" id="kmc_par_alg"></a>
Parallel approximate Kinetic Monte Carlo algorithm</h1>
<p>The lattice in a parallel kMC simulation is partitioned among the processors in an MPI communicator. There are two methods of decomposition. The simplest is row-based decomposition, shown below.</p>
<div class="image">
<img src="PartitionedLatticeRow.png" alt=""/>
</div>
 <p>In the above diagram, a lattice is divided among four processors with ranks ranging from 0 to 3. Here, &ldquo;ghost sites&rdquo; appear along the top and bottom of each partition of the lattice. The ghost regions along the edges of each partition are copies of the lattice sites of a neighboring processor, and in the diagram, the processor from which they are copied is shown via their color. Periodic boundary conditions are employed here, so that the top of the rank 0 partition is connected to the bottom of the rank 3 partition. Ghost regions are not needed for the left and right sides. Alternatively, the lattice may be decomposed such that the perimeter of each partition is minimized. Here, this is called <em>compact</em> decomposition, and is shown below.</p>
<div class="image">
<img src="PartitionedLatticeCompact.png" alt=""/>
</div>
 <p>Now, ghost regions are along the whole boundary of each portion of the lattice. Again, the lattice is shown divided among four processors with ranks ranging from 0 to 3.</p>
<p>Attempting to do kMC simulations on each partition of the lattice would lead to problems at the partition boundaries, since the events done on each partition could lead to conflicting effects on the ghost sites. To avoid this problem, an approximate kMC algorithm was developed <a class="el" href="citelist.html#CITEREF_shim05">[10]</a>, where each partition is further subdivided into sectors, and at any given time in the simulation, events are executed only for sites within one of these sectors, as illustrated below for the case of compact decomposition.</p>
<div class="image">
<img src="ActiveSectorsCompact.png" alt=""/>
</div>
 <p>Partition boundaries are indicated by thick solid lines, while the sector boundaries are indicated by thinner solid lines. Active sectors are shown in the color corresponding to the rank of the partition to which they belong. The dotted lines show the boundaries of the regions affected by events that occur within the active sectors. The parts of these regions that affect ghost sites are shown in the color corresponding to the ranks of the sites of which the ghost sites are copies. If row decomposition were used, there would be two sectors per partition instead of four. Here, in the above diagram, the active sectors happen to be the upper left quadrants of the lattice partitions. At any given time in the simulation, they could be the lower left, lower right, or upper right quadrants, so long as the relative locations of these active sectors are the same for all processors, that is, <em>all</em> upper left, <em>all</em> lower left, and so on. Because the active sectors all have the same relative location, the regions that are affected by events happening within them do not overlap, as illustrated by the diagram above.</p>
<p>With the sectors now defined, the approximate kMC algorithm can proceed on each processor as follows:</p>
<ol type="1">
<li>Initialize the global time <em>t</em> to zero.</li>
<li>Determine the initial value of the stop time \(t_{stop}\).</li>
<li>Repeat the following until <em>t</em> exceed the desired time \(t_{max}\):<ol type="a">
<li>Iterate over the sectors. For each sector visited,<ol type="i">
<li>initialize the local time \(t_{local}\) to zero,</li>
<li>update the ghost sites and the set of possible events affected by changes to the ghost sites,</li>
<li>run a normal serial kMC algorithm on the sites within the sector, incrementing \(t_{local}\) as each event is executed until \(t_{local} &gt; t_{stop}\), but do not allow the event that would cause \(t_{local}\) to exceed \(t_{stop}\) to be executed, and</li>
<li>update the off-processor sites that correspond to the ghost sites that have changed due to the events that have occurred, and again update the set of possible events affected by the ghost site updates.</li>
</ol>
</li>
<li>Increment the global time <em>t</em> by \(t_{stop}\).</li>
<li>Update the value of \(t_{stop}\).</li>
</ol>
</li>
</ol>
<p>The updates of the ghost sites that are performed when a sector is visited do not involve communicating the entirety of the ghost site regions bordering a sector, only the communication of <em>changes</em> to each region.</p>
<p>In principle, the sequence in which the sectors are visited may be random, so long as (1) each processor uses the same random sequences (in order that the active sectors on each processor are at the same relative location, as mentioned previously), and (2) that four sectors are visited before the global time is incremented. However, in the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library, the simpler approach seen in another kMC code, SPPARKS <a class="el" href="citelist.html#CITEREF_plim23">[7]</a>, is taken, where each sector is simply visited in turn in a deterministic loop. In the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library, this loop begins at the upper left and then continues to the lower left, followed by the lower right and upper right.</p>
<p>Compact decomposition, despite minimizing the perimeter of each partition, may be slower than row-based decomposition, because the former mode of decomposition requires twice as many sectors as the latter, and each visit of a sector requires the communication of ghosts. The volume of data communicated in row-based decomposition may indeed be higher than that in compact decomposition. However, since only changes to ghost regions are communicated, this volume is not that high to begin with, so the communication overhead is dominated more by the very acts of sending and receiving messages, rather the costs associated with the size of the data itself. Because of this, row-based decomposition is the default in the ARL <a class="el" href="namespaceKMCThinFilm.html">KMCThinFilm</a> library.</p>
<p>The value of \(t_{stop}\) may be determined by various time-stepping schemes. The simplest of these is to set \(t_{stop}\) to a fixed value. The other schemes are various kinds of adaptive algorithms, which attempt to determine a reasonable value of \(t_{stop}\) from the propensities of the possible events in the simulation. In all of these algorithms, the time step has the general form,   </p><p class="formulaDsp">
\[t_{stop} = \frac{n_{stop}}{F_{stop}}
\]
</p>
<p> where \(n_{stop}\) is an adjustable parameter, and \(F_{stop}\) is a function that determines the particular adaptive time step scheme. Here are the currently available choices for \(F_{stop}\):</p>
<ul>
<li>The maximum propensity of all currently possible cell-centered events in the simulation. This is a simplified version of the adaptive method of determining \(F_{stop}\) recommended by <a class="el" href="citelist.html#CITEREF_shim05">[10]</a>. When this method is used, a good conservative value of \(n_{stop}\) is 1.0, though in some applications, such as island coarsening, a value of up to 10.0 has been used without much loss of accuracy <a class="el" href="citelist.html#CITEREF_shi07">[9]</a>.</li>
<li>The maximum of the average propensities per possible cell-centered event from each sector.  \(F_{stop} = \max(p_s^1,
  p_s^2, \dots, p_s^{N_{proc}})\), where \(N_{proc}\) is the number of processors and for the case of compact decomposition, \(p_s^n = \max(p_{s,UL}^n,p_{s,LL}^n,p_{s,LR}^n,p_{s,UR}^n)\), where \(p_{s,UL}^n\) is the average propensity of the events in the upper-left sector of partition <em>n</em>, that is, the sum of the propensities of all possible events in that sector divided by the number of possible events, and similarly, \(p_{s,LL}^n\), \(p_{s,LR}^n\), and \(p_{s,UR}^n\) are the mean propensities in the lower left, lower right, and upper right sectors of partition <em>n</em>, as in SPPARKS <a class="el" href="citelist.html#CITEREF_plim23">[7]</a>. For this choice of \(F_{stop}\), a reasonable starting value for \(n_{stop}\) is 1.0. Note that for a given value of \(n_{stop}\), this approach may be less conservative than the previous one.</li>
</ul>
<p>An additional optional parameter \(t_{stop,max}\) may be used with the adaptive schemes. If this parameter is set, then if \(n_{stop}/F_{stop} &gt; t_{stop,max}\), \(t_{stop}\) will equal \(t_{stop,max}\) instead of \(n_{stop}/F_{stop}\). This may be useful in cases where the adaptive scheme temporarily overestimates \(t_{stop}\) during a simulation.</p>
<p>In a parallel simulation, the propensity of an over-lattice event is the propensity per unit area scaled by the in-plane area of a <em>sector</em>, rather than the size of a whole monolayer. Also, running a parallel simulation changes how periodic actions are run. In a serial simulation, if a periodic action executes, it executes shortly after an event has been executed. In a parallel simulation, if a periodic action executes, it executes shortly after \(t_{stop}\) has been incremented, that is, outside of the looping over sectors. This allows periodic actions to use MPI calls for parallel communication, since a periodic action will execute the same number of times on every processor. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
